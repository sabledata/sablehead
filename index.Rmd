---
title: "Development of methods in support of a head-only catch sampling program for sablefish (*Anoplopoma fimbria*) in British Columbia"
year: 2022
report_number: nnn
author: |
  Lisa C. Lacko and Kathryn L. Temple and 
  Kendra R. Holt and Janine x. Supernault
author_list: "L.C. Lacko, Kathryn L. Temple and Holt K.R. and Supernault J.x."
region: Pacific Region
isbn: ""
address: |
     Pacific Biological Station\
     Fisheries and Oceans Canada, 3190 Hammond Bay Road\
     Nanaimo, British Columbia, V9T 6N7, Canada\
phone: "(250) 756-7000"
author_footnote: "Email: Lacko.Lisa@dfo-mpo.gc.ca | telephone: (778) 268-3236"
abstract: |
  Routine biological sampling of whole round sablefish from commercial fishing operations in British Columbia began the early 1990’s.  Historically, specimens were obtained through the voluntary fishery catch sampling and tag recovery programs.   We investigate the potential for obtaining sex and length information using heads, rather than the entire fish. In 2016, 438 sablefish (240-1080 mm) were sampled at sea and six different fish head measurements were collected. Genetic samples (137) were obtained to develop methods of DNA-based sex identification.  A pilot study occurred in 2017 with 360 head-only samples collected and sexed by a commercial vessel, followed by scientific sampling on shore.  Regression analysis results reveal that all six cranial dimensions can be used to accurately predict length. However, interorbital distance was not only a good predictor of length, but samplers ranked it the most efficient to measure and easily repeatable. Genomic DNA were successfully processed for 130 of the 137 samples. Fisher sex determination was accurate xx% of the time. Given the results, the 2018 sampling collection program was modified so that returns of whole round sablefish were replaced by head-only samples with knife cuts on the operculum to indicate sex.

abstract_other: |

 
output:
 csasdown::techreport_pdf:
   french: false
type:
  techreport
# ------------Abstract word count 199 out of 200 limit
# End of options to set
knit: bookdown::render_book
site: bookdown::bookdown_site
link-citations: true
bibliography: bib/refs.bib
csl: csl/csas.csl
lot: true
lof: true
# Any extra LaTeX code for the header:
# header-includes:
# - \usepackage{tikz}
header-includes: \usepackage{pdflscape}
                 
---

```{r setup, echo=FALSE, cache=FALSE, message=FALSE, results='hide', warning=FALSE}
library(knitr)
if (is_latex_output()) {
  knitr_figs_dir  <- "knitr-figs-pdf/"
  knitr_cache_dir <- "knitr-cache-pdf/"
  fig_out_type    <- "png"
} else {
  knitr_figs_dir  <- "knitr-figs-docx/"
  knitr_cache_dir <- "knitr-cache-docx/"
  fig_out_type    <- "png"
}
fig_asp   <- 0.618
fig_width <- 9
fig_out_width <- "6in"
fig_dpi   <- 180
fig_align <- "center"
fig_pos   <- "htb"
opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  comment = "#>",
  fig.path = knitr_figs_dir,
  cache.path = knitr_cache_dir,
  fig.asp = fig_asp,
  fig.width = fig_width,
  out.width = fig_out_width,
  echo = FALSE,
  #  autodep = TRUE,
  #  cache = TRUE,
  cache.comments = FALSE,
  dev = fig_out_type,
  dpi = fig_dpi,
  fig.align = fig_align,
  fig.pos = fig_pos
)
options(xtable.comment = FALSE)
options(kableExtra.latex.load_packages = FALSE)
```

```{r load-libraries, cache=FALSE}
# add other packages here:
library(csasdown)
message("year = ", rmarkdown::metadata$year)
#browser()
yr              <-  2021
path            <-  "c:/github/sablehead/standalone/"
graph_directory <-  "c:/github/sablehead/figures/"

library(RODBC)
library(knitr)
library(magick)
library(excelR)
library(gapminder)
library(ggplot2)
library(dplyr)        # transform and summarize tabular data
library(xtable)       # produces tables
library(kableExtra)   # produces html tables with scrollbars, etc
library(pacman)       # produces numbered tables and figures in order to reference them
 #  if (!require("pacman")) install.packages("pacman")
 #  pacman::p_load(knitr, captioner, bundesligR, stringr)
library(bookdown)
library(tableHTML)
library(Rmisc)
library(cowplot)
library(rgdal)
library(maps)
library(ggspatial)
library(png)
library(grid)
library(gridExtra)
library(stringr)
library(ggpubr)
library(here)
library(ggfortify)
library(rgdal)

#  ----   G L O B A L --- F U N C T I O N S ---------------------------------
  GetSQLData <- function(strSQL,strDbName) {    # connect to SQL Server
         cnn <- odbcDriverConnect(paste("Driver={SQL Server};Server=DFBCV9TWVASP001;", 
                                         "Database=",
                                          strDbName,";
                                          Trusted_Connection=Yes",
                                          sep=""))
         dat <- sqlQuery(cnn, strSQL)
         odbcClose(cnn)
         return(dat) 
                                            }
  
  panLab <- function( x, y, txt, ... ) { # Allows text to be placed at 0<x<1, 0<y<1)
            usr <- par( "usr" )
            par( usr=c(0,1,0,1) )
            text( x, y, txt, ... )
            par( usr=usr )
            #return( NULL )
            }
  
  cleanf <- function(x){                            # function to remove duplicates
            oldx <- c(FALSE, x[-1]==x[-length(x)])  # is value equal to previous value
            res <- x
            res[oldx] <- NA
            return(res)
            } 
  
  simpleCap <- function(x) {  # add capital first letter to each word
            s <- strsplit(x, " ")[[1]]
            paste(toupper(substring(s, 1,1)), substring(s, 2),
            sep="", 
            collapse=" ")
            }
  
  firstup <- function(x) {   # add capital first letter to first word
            substr(x, 1, 1) <- toupper(substr(x, 1, 1))
            x
            }
  
  format_cells <- function(df, rows ,cols, value = c("italics", "bold", "strikethrough")){
            # select the correct markup
            map    <- setNames(c("*", "**", "~~"), c("italics", "bold", "strikethrough"))
            markup <- map[value]  
            
            for (r in rows){
                  for(c in cols){
                      df[[c]] <- as.character( df[[c]])  # -- make sure values not factors
                      df[r, c] <- paste0(markup, df[r, c], markup)  # -- Update formatting
                                }
                           }
                     return(df)
            }
            
  fig_label <- function(text, region="figure", pos="topleft", cex=NULL, ...) {
           
            region <- match.arg(region, c("figure", "plot", "device"))
            pos    <- match.arg(pos,    c("topleft",    "top", "topright", 
                                          "left",       "center", "right", 
                                          "bottomleft", "bottom", "bottomright"))
           
            if(region %in% c("figure", "device")) {
              ds <- dev.size("in")
              # xy coordinates of device corners in user co ordinates
              x <- grconvertX(c(0, ds[1]), from="in", to="user")
              y <- grconvertY(c(0, ds[2]), from="in", to="user")
           
              # fragment of the device we use to plot
              if(region == "figure") {
                # account for the fragment of the device that 
                # the figure is using
                fig <- par("fig")
                dx <- (x[2] - x[1])
                dy <- (y[2] - y[1])
                x <- x[1] + dx * fig[1:2]
                y <- y[1] + dy * fig[3:4]
              } 
            }
           
            # much simpler if in plotting region
            if(region == "plot") {
              u <- par("usr")
              x <- u[1:2]
              y <- u[3:4]
            }
           
            sw <- strwidth(text, cex=cex) * 60/100
            sh <- strheight(text, cex=cex) * 60/100
           
            x1 <- switch(pos,
              topleft     =x[1] + sw, 
              left        =x[1] + sw,
              bottomleft  =x[1] + sw,
              top         =(x[1] + x[2])/2,
              center      =(x[1] + x[2])/2,
              bottom      =(x[1] + x[2])/2,
              topright    =x[2] - sw,
              right       =x[2] - sw,
              bottomright =x[2] - sw)
           
            y1 <- switch(pos,
              topleft     =y[2] - sh,
              top         =y[2] - sh,
              topright    =y[2] - sh,
              left        =(y[1] + y[2])/2,
              center      =(y[1] + y[2])/2,
              right       =(y[1] + y[2])/2,
              bottomleft  =y[1] + sh,
              bottom      =y[1] + sh,
              bottomright =y[1] + sh)
           
            old.par <- par(xpd=NA)
            on.exit(par(old.par))
           
            text(x1, y1, text, cex=cex, ...)
            return(invisible(c(x,y)))
}
  
```

``` {r GlobalDataTable}
    # head measurements from research study 2016
    details <-    paste("select * from Head_Measurements_Report", sep="")
    # hd     <-    GetSQLData(details,"Sablefish")      # head details from SQL Server

    # write.table(hd , file = paste(path,"head_measurements.csv",sep=''),row.names=FALSE, na="",col.names=TRUE,  sep=",")
    hd      <-    read.csv(paste(path,"head_measurements.csv",sep=''), header = T)  # master data
    
    # separate out the 2016 research data for scatterplots
    hdUj  <- select(filter(hd, Upper_jaw_length > 0), SPECIMEN_ID,SPECIMEN_SEX_DESC,Fork_Length,Whole_Round_Weight, HeadBarcode, Upper_jaw_length) 
    hdUj  <- hdUj%>% mutate(measure = 'UJ')  # upper jaw length data

    hdEd  <- select(filter(hd, Eye_Diameter > 0), SPECIMEN_ID,SPECIMEN_SEX_DESC,Fork_Length,Whole_Round_Weight, HeadBarcode, Eye_Diameter)
    hdEd  <- hdEd%>% mutate(measure = 'ED') # Eye Diameter data
    
    hdId  <- select(filter(hd, InterOrbital_Distance > 0), SPECIMEN_ID,SPECIMEN_SEX_DESC,Fork_Length,Whole_Round_Weight, HeadBarcode, InterOrbital_Distance)
    hdId  <- hdId%>% mutate(measure = 'ID') # InterOrbital Distance data
    
    hdSl <-  select(filter(hd, Snout_length > 0), SPECIMEN_ID,SPECIMEN_SEX_DESC,Fork_Length,Whole_Round_Weight, HeadBarcode, Snout_length)  
    hdSl <-  hdSl%>% mutate(measure = 'SL') # Snout length data
    
    hdPop <- select(filter(hd, Postorbital_Preoperculum > 0), SPECIMEN_ID,SPECIMEN_SEX_DESC,Fork_Length,Whole_Round_Weight, HeadBarcode, Postorbital_Preoperculum )        
    hdPop <- hdPop%>% mutate(measure = 'PP')  # Postorbital Preoperculum data
    
    hdPo  <- select(filter(hd, Post_orbital_Head_length > 0), SPECIMEN_ID,SPECIMEN_SEX_DESC,Fork_Length,Whole_Round_Weight, HeadBarcode, Post_orbital_Head_length)   
    hdPo  <- hdPo%>% mutate(measure = 'PO')   # Post orbital Head length data
    
    # head measurements from pilot study, trip to seamount
    head99    <-  read.csv(paste(path,"head_measurements_Seamount_Pilot.csv",sep=""), header = T)
    head99$id <-  as.numeric(str_sub(head99$DNA.VIAL.BARCODE, 10, 12)) - 200   # add id column
    #count99   <-  table(head99['White.bag.label'])  # count of how many came from Cobb and Eickelberg ERROR!
    countCobb   <-  length(head99[head99$White.bag.label == "COBB",])
    countEick   <-  length(head99[head99$White.bag.label == "EICKELBERG",])
    
    library(dplyr)
    library(matrixStats)
    
    # create sample table with Mean and SDev in 2 columns
    mhd.ID  <- c('InterOrbital.DistanceA','InterOrbital.DistanceB','InterOrbital.DistanceC')
    mhd.SL  <- c('Snout.lengthA','Snout.lengthB','Snout.lengthC')  
    mhd.UJ  <- c('Upper.jaw.lengthA','Upper.jaw.lengthB','Upper.jaw.lengthC')  
    mhd.PP  <- c('Post.orbital.to.PreoperculumA','Post.orbital.to.PreoperculumB','Post.orbital.to.PreoperculumC')     

    # mean and sdev added
    head99.data <- head99 %>% 
                   mutate(ID.Mean= rowMeans(.[mhd.ID]), ID.stdev=rowSds(as.matrix(.[mhd.ID])),
                          SL.Mean= rowMeans(.[mhd.SL]), SL.stdev=rowSds(as.matrix(.[mhd.SL])),
                          UJ.Mean= rowMeans(.[mhd.UJ]), UJ.stdev=rowSds(as.matrix(.[mhd.UJ])),
                          PP.Mean= rowMeans(.[mhd.PP]), PP.stdev=rowSds(as.matrix(.[mhd.PP]))   )
    
    head99.dat   <- head99.data[order(head99.data$ID.Mean),]
    num          <- length(head99.dat$id)  # count fish
    head99.dat$observation   <- c(1:num)
 
    # master data for 99 head measurements
    sample.ID  <-   cbind(type='ID',head99.dat[,c(34,25:27,    6,11,16)])
    sample.SL  <-   cbind(type='SL',head99.dat[,c(34,25,28,29, 7,12,17)] )
    sample.UJ  <-   cbind(type='UJ',head99.dat[,c(34,25,30,31, 8,13,18)] )
    sample.PP  <-   cbind(type='PP',head99.dat[,c(34,25,32,33, 9,14,19)] )
    
    colnames(sample.SL) <- colnames(sample.ID)
    colnames(sample.UJ) <- colnames(sample.ID)
    colnames(sample.PP) <- colnames(sample.ID)    
    
    samples         <-   rbind(sample.ID, sample.SL, sample.UJ, sample.PP )
    names(samples)  <-  c("type","obs","id","SMean","Sstdev","A","B","C")
    #print(tail(samples,44))

    write.table(samples, file = paste(path,"export.samples.csv", sep=''), row.names=FALSE, na="", col.names=TRUE, sep=",")
    
    # now add columns for IAE:  Index of Average Error
    head99.dat  <- head99.dat %>%   #IAE = 1/N Σ (1/RΣ (|Xij - Xj|/ Xj))
                   mutate(IDSumABCDiv3techs = (abs((InterOrbital.DistanceA-ID.Mean)/ID.Mean) + 
                                               abs((InterOrbital.DistanceB-ID.Mean)/ID.Mean) + 
                                               abs((InterOrbital.DistanceC-ID.Mean)/ID.Mean))/3,
                          SLSumABCDiv3techs = (abs((Snout.lengthA-SL.Mean)/SL.Mean) + 
                                               abs((Snout.lengthB-SL.Mean)/SL.Mean) + 
                                               abs((Snout.lengthC-SL.Mean)/SL.Mean))/3,
                          UJSumABCDiv3techs = (abs((Upper.jaw.lengthA-UJ.Mean)/UJ.Mean) + 
                                               abs((Upper.jaw.lengthB-UJ.Mean)/UJ.Mean) + 
                                               abs((Upper.jaw.lengthC-UJ.Mean)/UJ.Mean))/3,
                          PPSumABCDiv3techs = (abs((Post.orbital.to.PreoperculumA-PP.Mean)/PP.Mean) + 
                                               abs((Post.orbital.to.PreoperculumB-PP.Mean)/PP.Mean) + 
                                               abs((Post.orbital.to.PreoperculumC-PP.Mean)/PP.Mean))/3 )

    #IAE = 1/N Σ (1/RΣ (|Xij - Xj|/ Xj))  sum of all calcs/ 99
    IAE.ID <- round(sum(head99.dat$IDSumABCDiv3techs) / length(head99.dat$IDSumABCDiv3techs) * 100.0,1)  
    IAE.SL <- round(sum(head99.dat$SLSumABCDiv3techs) / length(head99.dat$SLSumABCDiv3techs) * 100.0,1)
    IAE.UJ <- round(sum(head99.dat$UJSumABCDiv3techs) / length(head99.dat$UJSumABCDiv3techs) * 100.0,1)
    IAE.PP <- round(sum(head99.dat$PPSumABCDiv3techs) / length(head99.dat$PPSumABCDiv3techs) * 100.0,1)
    
    # results of IAE
    # print(paste("ID=",format(IAE.ID,1),"SL=",IAE.SL,"UJ=",IAE.UJ,"PP=",IAE.PP))
    
    
```
```{r yisFORKLENGTH}

    lmp <- function (modelobject) {                    #  p value function
           if (class(modelobject) != "lm") stop("Not an object of class 'lm' ")
                 f <- summary(modelobject)$fstatistic
                 p <- pf(f[1],f[2],f[3],lower.tail=F)
                 attributes(p) <- NULL
                 return(p)
    }

    lmslp <- function (modelobject) {                    #  slope (m) value function
             if (class(modelobject) != "lm") stop("Not an object of class 'lm' ")
                 slp <- signif(modelobject$coef[[2]], 5)
                 return(slp)
    }
    
    lmR <- function (modelobject) {                    #  r2 value function
             if (class(modelobject) != "lm") stop("Not an object of class 'lm' ")
                 r2 =  format(summary(modelobject)$r.squared,  digits = 3)
                 return(r2)
    }
    
    
    # y = Fork_Length, response variable
    options("scipen"=100, "digits"=3)
    

```    

