---
title: |
  "Development of methods in support of a head-only sampling program for Sablefish (*Anoplopoma fimbria*) in British Columbia"
french_title: Titre ici (*Nom latin de l'espèce*)
year: 2023
report_number: nnn
author: |
  First. M. Last^1^ and
  Alex B. Smith^2^
author_list: "Last, F.M. and Smith, A.B."
region: Pacific Region
french_region: Région du Pacifique
isbn: ""
address: |
  ^1^Pacific Biological Station\
     Fisheries and Oceans Canada, 3190 Hammond Bay Road\
     Nanaimo, British Columbia, V9T 6N7, Canada\
  ^2^Far, far away\
     Another Galaxy
french_address: |
  ^1^Station biologique du Pacifique\
     Pêches et Océans Canada, 3190 Hammond Bay Road\
     Nanaimo, Colombie-Britannique, V9T 6N7, Canada\
  \smallskip
  ^2^Loin, très loin\
     Une autre galaxie
phone: "(555) 555-5555"
author_footnote: "Email: Lacko.Lisa@dfo-mpo.gc.ca | telephone: (778) 268-3236"
abstract: |
    Routine biological sampling of whole round Sablefish from commercial fishing operations in British Columbia began the early 1990’s.  Historically, round specimens were obtained through a voluntary commercial fishery catch sampling and tag recovery programs.   We investigate the potential for obtaining sex and length information using heads, rather than the entire fish to promote participation in the sampling programs. In 2016, 438 Sablefish (240-1080 mm) were sampled at sea and six different fish head measurements were collected. Genetic samples (137) were obtained to develop methods of DNA-based sex identification. Regression analysis results reveal that all six cranial dimensions can be used to accurately predict length. However, interorbital distance was not only a good predictor of length, but samplers ranked it the most efficient to measure and easily repeatable. A pilot study occurred in 2017 with 360 head-only samples collected and sexed by a commercial vessel, followed by scientific sampling on shore. Genomic DNA were successfully processed for 80 of 99 samples. Fisher sex determination was accurate 84% of the time. Given the results, the 2018 commercial sampling collection program was modified so that returns of whole round Sablefish were replaced by head-only samples with knife cuts on the operculum to indicate sex.
french_abstract: |
  Voici le résumé. Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
output:
 csasdown::techreport_pdf:
   french: false
   # copy_sty is a toggle to copy the style file from the csasdown package every time you compile
   # the document. If false, any changes you have made to the style file in your project
   # will remain between compilations. If true, your changes will be lost when you compile
   copy_sty: true
   # line_nums is a toggle to show line numbers on the left side of the page. 
   line_nums: true
   # line_nums_mod represents showing every Nth line if line_nums is true
   line_nums_mod: 1
   # lot_lof is a toggle to show/not show the lists of tables and figures at the
   # beginning of the document
   lot_lof: false
   # draft_watermark is a toggle to show/not show a DRAFT watermark across every page
   draft_watermark: false
   # highlight is the theme to use for code output. Must be one of the list given by:
   # pandoc --list-highlight-styles
   # which are:
   # pygments, tango, espresso, zenburn, kate, monochrome, breezedark, haddock
   # or the name of a custom *.latex file which is most easily made by copying one from 
   # the csasdown library 'themes' directory, this directory on your machine:
   # file.path(.libPaths(), "csasdown", "themes")
   # to your working directory (the one containing index.Rmd)
   # To change the foreground text color, change the RGB value in the line containing
   # 'DefineVerbatimEnvironment'
   # To change background color, change the RGB values in the line containing 'shadecolor'
   highlight: tango
type:
  techreport
# ------------
# End of options to set
knit: (function(input, ...) {
       csasdown::render('_bookdown.yml')
      })
site: bookdown::bookdown_site
link-citations: true
bibliography: bib/refs.bib
# Any extra LaTeX code for the header:
header-includes:
 - \usepackage{float}
---

```{r setup, echo=FALSE, cache=FALSE, message=FALSE, results='hide', warning=FALSE}
library(knitr)
if (is_latex_output()) {
  knitr_figs_dir <- "knitr-figs-pdf/"
  knitr_cache_dir <- "knitr-cache-pdf/"
  fig_out_type <- "png"
} else {
  knitr_figs_dir <- "knitr-figs-docx/"
  knitr_cache_dir <- "knitr-cache-docx/"
  fig_out_type <- "png"
}
fig_asp <- 0.618
fig_width <- 9
fig_out_width <- "6in"
fig_dpi <- 180
fig_align <- "center"
fig_pos <- "htb"
opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  comment = "#>",
  fig.path = knitr_figs_dir,
  cache.path = knitr_cache_dir,
  fig.asp = fig_asp,
  fig.width = fig_width,
  out.width = fig_out_width,
  echo = FALSE,
  #  autodep = TRUE,
  #  cache = TRUE,
  cache.comments = FALSE,
  dev = fig_out_type,
  dpi = fig_dpi,
  fig.align = fig_align,
  fig.pos = fig_pos
)
```

```{r load-libraries, cache=FALSE}
# add other packages here:
library(dplyr) # transform and summarize tabular data
library(ggplot2)
library(readr)
library(tibble)
library(rosettafish)
library(csasdown)

yr              <-  2023
path            <-  "C:/github/sablehead/standalone/"
graph_directory <-  "C:/github/sablehead/figures/"
 
library(RODBC)
library(knitr)
library(magick)
library(excelR)
library(gapminder)
library(xtable)       # produces tables
library(kableExtra)   # produces html tables with scrollbars, etc
library(pacman)       # produces numbered tables and figures in order to reference them
 #  if (!require("pacman")) install.packages("pacman")
 #  pacman::p_load(knitr, captioner, bundesligR, stringr)
library(bookdown)
library(tableHTML)
library(Rmisc)
library(cowplot)
library(rgdal)
library(maps)
library(ggspatial)
library(png)
library(grid)
library(gridExtra)
library(stringr)
library(ggpubr)
library(here)
library(ggfortify)  # for maturity plots
library(rgdal)

#  ----   G L O B A L --- F U N C T I O N S ---------------------------------
  GetSQLData <- function(strSQL,strDbName) {    # connect to SQL Server
         cnn <- odbcDriverConnect(paste("Driver={SQL Server};Server=DFBCV9TWVASP001;", 
                                         "Database=",
                                          strDbName,";
                                          Trusted_Connection=Yes",
                                          sep=""))
         dat <- sqlQuery(cnn, strSQL)
         odbcClose(cnn)
         return(dat) 
                                            }
  
  panLab <- function( x, y, txt, ... ) { # Allows text to be placed at 0<x<1, 0<y<1)
            usr <- par( "usr" )
            par( usr=c(0,1,0,1) )
            text( x, y, txt, ... )
            par( usr=usr )
            #return( NULL )
            }
  
  cleanf <- function(x){                            # function to remove duplicates
            oldx <- c(FALSE, x[-1]==x[-length(x)])  # is value equal to previous value
            res <- x
            res[oldx] <- NA
            return(res)
            } 
  
  simpleCap <- function(x) {  # add capital first letter to each word
            s <- strsplit(x, " ")[[1]]
            paste(toupper(substring(s, 1,1)), substring(s, 2),
            sep="", 
            collapse=" ")
            }
  
  firstup <- function(x) {   # add capital first letter to first word
            substr(x, 1, 1) <- toupper(substr(x, 1, 1))
            x
            }
  
  format_cells <- function(df, rows ,cols, value = c("italics", "bold", "strikethrough")){
            # select the correct markup
            map    <- setNames(c("*", "**", "~~"), c("italics", "bold", "strikethrough"))
            markup <- map[value]  
            
            for (r in rows){
                  for(c in cols){
                      df[[c]] <- as.character( df[[c]])  # -- make sure values not factors
                      df[r, c] <- paste0(markup, df[r, c], markup)  # -- Update formatting
                                }
                           }
                     return(df)
            }
            
  fig_label <- function(text, region="figure", pos="topleft", cex=NULL, ...) {
           
            region <- match.arg(region, c("figure", "plot", "device"))
            pos    <- match.arg(pos,    c("topleft",    "top", "topright", 
                                          "left",       "center", "right", 
                                          "bottomleft", "bottom", "bottomright"))
           
            if(region %in% c("figure", "device")) {
              ds <- dev.size("in")
              # xy coordinates of device corners in user co ordinates
              x <- grconvertX(c(0, ds[1]), from="in", to="user")
              y <- grconvertY(c(0, ds[2]), from="in", to="user")
           
              # fragment of the device we use to plot
              if(region == "figure") {
                # account for the fragment of the device that 
                # the figure is using
                fig <- par("fig")
                dx <- (x[2] - x[1])
                dy <- (y[2] - y[1])
                x <- x[1] + dx * fig[1:2]
                y <- y[1] + dy * fig[3:4]
              } 
            }
           
            # much simpler if in plotting region
            if(region == "plot") {
              u <- par("usr")
              x <- u[1:2]
              y <- u[3:4]
            }
           
            sw <- strwidth(text, cex=cex) * 60/100
            sh <- strheight(text, cex=cex) * 60/100
           
            x1 <- switch(pos,
              topleft     =x[1] + sw, 
              left        =x[1] + sw,
              bottomleft  =x[1] + sw,
              top         =(x[1] + x[2])/2,
              center      =(x[1] + x[2])/2,
              bottom      =(x[1] + x[2])/2,
              topright    =x[2] - sw,
              right       =x[2] - sw,
              bottomright =x[2] - sw)
           
            y1 <- switch(pos,
              topleft     =y[2] - sh,
              top         =y[2] - sh,
              topright    =y[2] - sh,
              left        =(y[1] + y[2])/2,
              center      =(y[1] + y[2])/2,
              right       =(y[1] + y[2])/2,
              bottomleft  =y[1] + sh,
              bottom      =y[1] + sh,
              bottomright =y[1] + sh)
           
            old.par <- par(xpd=NA)
            on.exit(par(old.par))
           
            text(x1, y1, text, cex=cex, ...)
            return(invisible(c(x,y)))
}
  
```

``` {r GlobalDataTable}
    # head measurements from research study 2016 from trawl surveys and one salmon survey
    details <-    paste("select * from Head_Measurements_Report", sep="")
    # hd    <-    GetSQLData(details,"Sablefish")      # head details from SQL Server

    # write.table(hd , file = paste(path,"index_head_measurements.csv",sep=''),
    # row.names=FALSE, na="",col.names=TRUE,  sep=",")

    hd      <-    read.csv(paste(path,"index_head_measurements.csv",sep=''), header = T)  # master data
    
    # separate out the 2016 research data for scatterplots
    hdUj  <- select(filter(hd, Upper_jaw_length > 0), SPECIMEN_ID,SPECIMEN_SEX_DESC,
                    Fork_Length,Whole_Round_Weight, HeadBarcode, Upper_jaw_length) 
    hdUj  <- hdUj%>% mutate(measure = 'UJ')  # upper jaw length data

    hdEd  <- select(filter(hd, Eye_Diameter > 0), SPECIMEN_ID,SPECIMEN_SEX_DESC,Fork_Length,
                    Whole_Round_Weight, HeadBarcode, Eye_Diameter)
    hdEd  <- hdEd%>% mutate(measure = 'ED') # Eye Diameter data
    
    hdId  <- select(filter(hd, InterOrbital_Distance > 0), SPECIMEN_ID,SPECIMEN_SEX_DESC,Fork_Length,
                    Whole_Round_Weight, HeadBarcode, InterOrbital_Distance)
    hdId  <- hdId%>% mutate(measure = 'ID') # InterOrbital Distance data
    
    hdSl <-  select(filter(hd, Snout_length > 0), SPECIMEN_ID,SPECIMEN_SEX_DESC,
                    Fork_Length,Whole_Round_Weight, HeadBarcode, Snout_length)  
    hdSl <-  hdSl%>% mutate(measure = 'SL') # Snout length data
    
    hdPop <- select(filter(hd, Postorbital_Preoperculum > 0), SPECIMEN_ID,SPECIMEN_SEX_DESC,
                    Fork_Length,Whole_Round_Weight, HeadBarcode, Postorbital_Preoperculum )        
    hdPop <- hdPop%>% mutate(measure = 'PP')  # Postorbital Preoperculum data
    
    hdPo  <- select(filter(hd, Post_orbital_Head_length > 0), SPECIMEN_ID,SPECIMEN_SEX_DESC,
                    Fork_Length,Whole_Round_Weight, HeadBarcode, Post_orbital_Head_length)   
    hdPo  <- hdPo%>% mutate(measure = 'PO')   # Post orbital Head length data
    
    # head measurements from pilot study, trip to seamount, contains Sampler A, B, C
    head99    <-  read.csv(paste(path,"index_head_measurements_Seamount_Pilot.csv",sep=""), header = T)
    head99$id <-  as.numeric(str_sub(head99$DNA.VIAL.BARCODE, 10, 12)) - 200   # add id column 1 to 99
    count99   <-  table(head99['White.bag.label'])  # count of how many came from Cobb and Eickelberg 

    library(dplyr)
    library(matrixStats)
    
    # create sample table with Mean and SDev in 2 columns
    mhd.ID  <- c('InterOrbital.DistanceA','InterOrbital.DistanceB','InterOrbital.DistanceC')
    mhd.SL  <- c('Snout.lengthA','Snout.lengthB','Snout.lengthC')  
    mhd.UJ  <- c('Upper.jaw.lengthA','Upper.jaw.lengthB','Upper.jaw.lengthC')  
    mhd.PP  <- c('Post.orbital.to.PreoperculumA','Post.orbital.to.PreoperculumB',
                 'Post.orbital.to.PreoperculumC')     

    # mean and sdev added
    head99.data <- head99 %>% 
                   mutate(ID.Mean= rowMeans(.[mhd.ID]), ID.stdev=rowSds(as.matrix(.[mhd.ID])),
                          SL.Mean= rowMeans(.[mhd.SL]), SL.stdev=rowSds(as.matrix(.[mhd.SL])),
                          UJ.Mean= rowMeans(.[mhd.UJ]), UJ.stdev=rowSds(as.matrix(.[mhd.UJ])),
                          PP.Mean= rowMeans(.[mhd.PP]), PP.stdev=rowSds(as.matrix(.[mhd.PP]))   )
    
    head99.dat   <- head99.data[order(head99.data$ID.Mean),]
    num          <- length(head99.dat$id)  # count fish
    head99.dat$observation   <- c(1:num)
 
    # master data for 99 head measurements
    sample.ID  <-   cbind(type='ID',head99.dat[,c(34,25:27,    6,11,16)])
    sample.SL  <-   cbind(type='SL',head99.dat[,c(34,25,28,29, 7,12,17)] )
    sample.UJ  <-   cbind(type='UJ',head99.dat[,c(34,25,30,31, 8,13,18)] )
    sample.PP  <-   cbind(type='PP',head99.dat[,c(34,25,32,33, 9,14,19)] )
    
    colnames(sample.SL) <- colnames(sample.ID)
    colnames(sample.UJ) <- colnames(sample.ID)
    colnames(sample.PP) <- colnames(sample.ID)    
    
    samples         <-   rbind(sample.ID, sample.SL, sample.UJ, sample.PP )
    names(samples)  <-  c("type","obs","id","SMean","Sstdev","A","B","C")
    #print(tail(samples,44))

    write.table(samples, file = paste(path,"index_export_Seamount_Pilot.csv", sep=''), 
                row.names=FALSE, na="", col.names=TRUE, sep=",")
    
    # now add columns for IAE:  Index of Average Error
    head99.dat  <- head99.dat %>%   #IAE = 1/N Σ (1/RΣ (|Xij - Xj|/ Xj))
                   mutate(IDSumABCDiv3techs = (abs((InterOrbital.DistanceA-ID.Mean)/ID.Mean) + 
                                               abs((InterOrbital.DistanceB-ID.Mean)/ID.Mean) + 
                                               abs((InterOrbital.DistanceC-ID.Mean)/ID.Mean))/3,
                          SLSumABCDiv3techs = (abs((Snout.lengthA-SL.Mean)/SL.Mean) + 
                                               abs((Snout.lengthB-SL.Mean)/SL.Mean) + 
                                               abs((Snout.lengthC-SL.Mean)/SL.Mean))/3,
                          UJSumABCDiv3techs = (abs((Upper.jaw.lengthA-UJ.Mean)/UJ.Mean) + 
                                               abs((Upper.jaw.lengthB-UJ.Mean)/UJ.Mean) + 
                                               abs((Upper.jaw.lengthC-UJ.Mean)/UJ.Mean))/3,
                          PPSumABCDiv3techs = (abs((Post.orbital.to.PreoperculumA-PP.Mean)/PP.Mean) + 
                                               abs((Post.orbital.to.PreoperculumB-PP.Mean)/PP.Mean) + 
                                               abs((Post.orbital.to.PreoperculumC-PP.Mean)/PP.Mean))/3 )

    #IAE = 1/N Σ (1/RΣ (|Xij - Xj|/ Xj))  sum of all calcs/ 99
    IAE.ID <- round(sum(head99.dat$IDSumABCDiv3techs) / length(head99.dat$IDSumABCDiv3techs) * 100.0,1)  
    IAE.SL <- round(sum(head99.dat$SLSumABCDiv3techs) / length(head99.dat$SLSumABCDiv3techs) * 100.0,1)
    IAE.UJ <- round(sum(head99.dat$UJSumABCDiv3techs) / length(head99.dat$UJSumABCDiv3techs) * 100.0,1)
    IAE.PP <- round(sum(head99.dat$PPSumABCDiv3techs) / length(head99.dat$PPSumABCDiv3techs) * 100.0,1)
    
    # results of IAE
    # print(paste("ID=",format(IAE.ID,1),"SL=",IAE.SL,"UJ=",IAE.UJ,"PP=",IAE.PP))
    
    
```
```{r yisFORKLENGTH}

    lmp <- function (modelobject) {                    #  p value function
           if (class(modelobject) != "lm") stop("Not an object of class 'lm' ")
                 f <- summary(modelobject)$fstatistic
                 p <- pf(f[1],f[2],f[3],lower.tail=F)
                 attributes(p) <- NULL
                 return(p)
    }

    lmslp <- function (modelobject) {                    #  slope (m) value function
             if (class(modelobject) != "lm") stop("Not an object of class 'lm' ")
                 slp <- signif(modelobject$coef[[2]], 5)
                 return(slp)
    }
    
    lmR <- function (modelobject) {                    #  r2 value function
             if (class(modelobject) != "lm") stop("Not an object of class 'lm' ")
                 r2 =  format(summary(modelobject)$r.squared,  digits = 3)
                 return(r2)
    }
    
    # y = Fork_Length, response variable
    options("scipen"=100, "digits"=3)


```
