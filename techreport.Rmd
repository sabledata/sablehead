---
title: "Estimation of fork length using cranial measurements of sablefish (*Anoplopoma fimbria*) in British Columbia"
year: 2022
report_number: nnn
author: |
  Kathryn x. Temple and Lisa C. Lacko and
  Kendra R. Holt and MGL person
author_list: "Kathryn x. Temple,  L.C. Lacko and Holt K.R. and MGL person"
region: Pacific Region
isbn: ""
address: |
     Pacific Biological Station\
     Fisheries and Oceans Canada, 3190 Hammond Bay Road\
     Nanaimo, British Columbia, V9T 6N7, Canada\
phone: "(250) 756-7000"
author_footnote: "Email: Kathryn.Temple@dfo-mpo.gc.ca | telephone: (250) 756-7366"
abstract: |
  Routine biological sampling of whole round sablefish from commercial fishing operations in British Columbia began the early 1990â€™s.  Historically, specimens were obtained through the voluntary fishery catch sampling and tag recovery programs.   We investigate the potential for obtaining sex and length information using heads, rather than the entire fish. In 2016, 438 sablefish (240-1080 mm) were sampled at sea and six different fish head measurements were collected. Genetic samples (137) were obtained to develop methods of DNA-based sex identification.  A pilot study occurred in 2017 with 360 head-only samples collected and sexed by a commercial vessel, followed by scientific sampling on shore.  Regression analysis results reveal that all six cranial dimensions can be used to accurately predict length. However, interorbital distance was not only a good predictor of length, but samplers ranked it the most efficient to measure and easily repeatable. Genomic DNA were successfully processed for 130 of the 137 samples. Fisher sex determination was accurate xx% of the time. Given the results, the 2018 sampling collection program was modified so that returns of whole round sablefish were replaced by head-only samples with knife cuts on the operculum to indicate sex.

abstract_other: |

 
output:
 csasdown::techreport_pdf:
   french: false
type:
  techreport
# ------------Abstract word count 199 out of 200 limit
# End of options to set
knit: bookdown::render_book
site: bookdown::bookdown_site
link-citations: true
bibliography: bib/refs.bib
csl: csl/csas.csl
lot: true
lof: true
# Any extra LaTeX code for the header:
# header-includes:
# - \usepackage{tikz}
header-includes: \usepackage{pdflscape}
                 
---

```{r setup, echo=FALSE, cache=FALSE, message=FALSE, results='hide', warning=FALSE}
library(knitr)
if (is_latex_output()) {
  knitr_figs_dir  <- "knitr-figs-pdf/"
  knitr_cache_dir <- "knitr-cache-pdf/"
  fig_out_type    <- "png"
} else {
  knitr_figs_dir  <- "knitr-figs-docx/"
  knitr_cache_dir <- "knitr-cache-docx/"
  fig_out_type    <- "png"
}
fig_asp   <- 0.618
fig_width <- 9
fig_out_width <- "6in"
fig_dpi   <- 180
fig_align <- "center"
fig_pos   <- "htb"
opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  comment = "#>",
  fig.path = knitr_figs_dir,
  cache.path = knitr_cache_dir,
  fig.asp = fig_asp,
  fig.width = fig_width,
  out.width = fig_out_width,
  echo = FALSE,
  #  autodep = TRUE,
  #  cache = TRUE,
  cache.comments = FALSE,
  dev = fig_out_type,
  dpi = fig_dpi,
  fig.align = fig_align,
  fig.pos = fig_pos
)
options(xtable.comment = FALSE)
options(kableExtra.latex.load_packages = FALSE)
```

```{r load-libraries, cache=FALSE}
# add other packages here:
library(csasdown)
message("year = ", rmarkdown::metadata$year)
#browser()
yr              <-  2021
path            <-  "c:/github/sablehead/standalone/"
graph_directory <-  "c:/github/sablehead/figures/"

library(RODBC)
library(knitr)
library(magick)
library(excelR)
library(gapminder)
library(ggplot2)
library(dplyr)        # transform and summarize tabular data
library(xtable)       # produces tables
library(kableExtra)   # produces html tables with scrollbars, etc
library(pacman)       # produces numbered tables and figures in order to reference them
 #  if (!require("pacman")) install.packages("pacman")
 #  pacman::p_load(knitr, captioner, bundesligR, stringr)
library(bookdown)
library(tableHTML)
library(Rmisc)
library(cowplot)
library(rgdal)
library(maps)
library(ggspatial)
library(png)
library(grid)
library(gridExtra)
library(stringr)
library(ggpubr)
library(here)
library(ggfortify)
library(rgdal)

#  ----   G L O B A L --- F U N C T I O N S ---------------------------------
  GetSQLData <- function(strSQL,strDbName) {    # connect to SQL Server
         cnn <- odbcDriverConnect(paste("Driver={SQL Server};Server=DFBCV9TWVASP001;", 
                                         "Database=",
                                          strDbName,";
                                          Trusted_Connection=Yes",
                                          sep=""))
         dat <- sqlQuery(cnn, strSQL)
         odbcClose(cnn)
         return(dat) 
                                            }
  
  panLab <- function( x, y, txt, ... ) { # Allows text to be placed at 0<x<1, 0<y<1)
            usr <- par( "usr" )
            par( usr=c(0,1,0,1) )
            text( x, y, txt, ... )
            par( usr=usr )
            #return( NULL )
            }
  
  cleanf <- function(x){                            # function to remove duplicates
            oldx <- c(FALSE, x[-1]==x[-length(x)])  # is value equal to previous value
            res <- x
            res[oldx] <- NA
            return(res)
            } 
  
  simpleCap <- function(x) {  # add capital first letter to each word
            s <- strsplit(x, " ")[[1]]
            paste(toupper(substring(s, 1,1)), substring(s, 2),
            sep="", 
            collapse=" ")
            }
  
  firstup <- function(x) {   # add capital first letter to first word
            substr(x, 1, 1) <- toupper(substr(x, 1, 1))
            x
            }
  
  format_cells <- function(df, rows ,cols, value = c("italics", "bold", "strikethrough")){
            # select the correct markup
            map    <- setNames(c("*", "**", "~~"), c("italics", "bold", "strikethrough"))
            markup <- map[value]  
            
            for (r in rows){
                  for(c in cols){
                      df[[c]] <- as.character( df[[c]])  # -- make sure values not factors
                      df[r, c] <- paste0(markup, df[r, c], markup)  # -- Update formatting
                                }
                           }
                     return(df)
            }
            
  fig_label <- function(text, region="figure", pos="topleft", cex=NULL, ...) {
           
            region <- match.arg(region, c("figure", "plot", "device"))
            pos    <- match.arg(pos,    c("topleft",    "top", "topright", 
                                          "left",       "center", "right", 
                                          "bottomleft", "bottom", "bottomright"))
           
            if(region %in% c("figure", "device")) {
              ds <- dev.size("in")
              # xy coordinates of device corners in user co ordinates
              x <- grconvertX(c(0, ds[1]), from="in", to="user")
              y <- grconvertY(c(0, ds[2]), from="in", to="user")
           
              # fragment of the device we use to plot
              if(region == "figure") {
                # account for the fragment of the device that 
                # the figure is using
                fig <- par("fig")
                dx <- (x[2] - x[1])
                dy <- (y[2] - y[1])
                x <- x[1] + dx * fig[1:2]
                y <- y[1] + dy * fig[3:4]
              } 
            }
           
            # much simpler if in plotting region
            if(region == "plot") {
              u <- par("usr")
              x <- u[1:2]
              y <- u[3:4]
            }
           
            sw <- strwidth(text, cex=cex) * 60/100
            sh <- strheight(text, cex=cex) * 60/100
           
            x1 <- switch(pos,
              topleft     =x[1] + sw, 
              left        =x[1] + sw,
              bottomleft  =x[1] + sw,
              top         =(x[1] + x[2])/2,
              center      =(x[1] + x[2])/2,
              bottom      =(x[1] + x[2])/2,
              topright    =x[2] - sw,
              right       =x[2] - sw,
              bottomright =x[2] - sw)
           
            y1 <- switch(pos,
              topleft     =y[2] - sh,
              top         =y[2] - sh,
              topright    =y[2] - sh,
              left        =(y[1] + y[2])/2,
              center      =(y[1] + y[2])/2,
              right       =(y[1] + y[2])/2,
              bottomleft  =y[1] + sh,
              bottom      =y[1] + sh,
              bottomright =y[1] + sh)
           
            old.par <- par(xpd=NA)
            on.exit(par(old.par))
           
            text(x1, y1, text, cex=cex, ...)
            return(invisible(c(x,y)))
}
  
```

``` {r GlobalDataTable}
    # head measurements from research study 2016
    details <-    paste("select * from Head_Measurements_Report", sep="")
    # hd     <-    GetSQLData(details,"Sablefish")      # head details from SQL Server

    # write.table(hd , file = paste(path,"head_measurements.csv",sep=''),row.names=FALSE, na="",col.names=TRUE,  sep=",")
    hd      <-    read.csv(paste(path,"head_measurements.csv",sep=''), header = T)  # master data
    
    # separate out the 2016 research data for scatterplots
    hdUj  <- select(filter(hd, Upper_jaw_length > 0), SPECIMEN_ID,SPECIMEN_SEX_DESC,Fork_Length,Whole_Round_Weight, HeadBarcode, Upper_jaw_length) 
    hdUj  <- hdUj%>% mutate(measure = 'UJ')  # upper jaw length data

    hdEd  <- select(filter(hd, Eye_Diameter > 0), SPECIMEN_ID,SPECIMEN_SEX_DESC,Fork_Length,Whole_Round_Weight, HeadBarcode, Eye_Diameter)
    hdEd  <- hdEd%>% mutate(measure = 'ED') # Eye Diameter data
    
    hdId  <- select(filter(hd, InterOrbital_Distance > 0), SPECIMEN_ID,SPECIMEN_SEX_DESC,Fork_Length,Whole_Round_Weight, HeadBarcode, InterOrbital_Distance)
    hdId  <- hdId%>% mutate(measure = 'ID') # InterOrbital Distance data
    
    hdSl <-  select(filter(hd, Snout_length > 0), SPECIMEN_ID,SPECIMEN_SEX_DESC,Fork_Length,Whole_Round_Weight, HeadBarcode, Snout_length)  
    hdSl <-  hdSl%>% mutate(measure = 'SL') # Snout length data
    
    hdPop <- select(filter(hd, Postorbital_Preoperculum > 0), SPECIMEN_ID,SPECIMEN_SEX_DESC,Fork_Length,Whole_Round_Weight, HeadBarcode, Postorbital_Preoperculum )        
    hdPop <- hdPop%>% mutate(measure = 'PP')  # Postorbital Preoperculum data
    
    hdPo  <- select(filter(hd, Post_orbital_Head_length > 0), SPECIMEN_ID,SPECIMEN_SEX_DESC,Fork_Length,Whole_Round_Weight, HeadBarcode, Post_orbital_Head_length)   
    hdPo  <- hdPo%>% mutate(measure = 'PO')   # Post orbital Head length data
    
    # head measurements from pilot study, trip to seamount
    head99    <-  read.csv(paste(path,"head_measurements_Seamount_Pilot.csv",sep=""), header = T)
    head99$id <-  as.numeric(str_sub(head99$DNA.VIAL.BARCODE, 10, 12)) - 200   # add id column
    count99   <-  table(head99['White.bag.label'])  # count of how many came from Cobb and Eickelberg
    
    library(dplyr)
    library(matrixStats)
    
    # create sample table with Mean and SDev in 2 columns
    mhd.ID  <- c('InterOrbital.DistanceA','InterOrbital.DistanceB','InterOrbital.DistanceC')
    mhd.SL  <- c('Snout.lengthA','Snout.lengthB','Snout.lengthC')  
    mhd.UJ  <- c('Upper.jaw.lengthA','Upper.jaw.lengthB','Upper.jaw.lengthC')  
    mhd.PP  <- c('Post.orbital.to.PreoperculumA','Post.orbital.to.PreoperculumB','Post.orbital.to.PreoperculumC')     

    # mean and sdev added
    head99.data <- head99 %>% 
                   mutate(ID.Mean= rowMeans(.[mhd.ID]), ID.stdev=rowSds(as.matrix(.[mhd.ID])),
                          SL.Mean= rowMeans(.[mhd.SL]), SL.stdev=rowSds(as.matrix(.[mhd.SL])),
                          UJ.Mean= rowMeans(.[mhd.UJ]), UJ.stdev=rowSds(as.matrix(.[mhd.UJ])),
                          PP.Mean= rowMeans(.[mhd.PP]), PP.stdev=rowSds(as.matrix(.[mhd.PP]))   )
    
    head99.dat   <- head99.data[order(head99.data$ID.Mean),]
    num          <- length(head99.dat$id)  # count fish
    head99.dat$observation   <- c(1:num)
 
    # master data for 99 head measurements
    sample.ID  <-   cbind(type='ID',head99.dat[,c(34,25:27,    6,11,16)])
    sample.SL  <-   cbind(type='SL',head99.dat[,c(34,25,28,29, 7,12,17)] )
    sample.UJ  <-   cbind(type='UJ',head99.dat[,c(34,25,30,31, 8,13,18)] )
    sample.PP  <-   cbind(type='PP',head99.dat[,c(34,25,32,33, 9,14,19)] )
    
    colnames(sample.SL) <- colnames(sample.ID)
    colnames(sample.UJ) <- colnames(sample.ID)
    colnames(sample.PP) <- colnames(sample.ID)    
    
    samples         <-   rbind(sample.ID, sample.SL, sample.UJ, sample.PP )
    names(samples)  <-  c("type","obs","id","SMean","Sstdev","A","B","C")
    #print(tail(samples,44))

    write.table(samples, file = paste(path,"export.samples.csv", sep=''), row.names=FALSE, na="", col.names=TRUE, sep=",")
    
    # now add columns for IAE:  Index of Average Error
    head99.dat  <- head99.dat %>%   #IAE = 1/N Î£ (1/RÎ£ (|Xij - Xj|/ Xj))
                   mutate(IDSumABCDiv3techs = (abs((InterOrbital.DistanceA-ID.Mean)/ID.Mean) + 
                                               abs((InterOrbital.DistanceB-ID.Mean)/ID.Mean) + 
                                               abs((InterOrbital.DistanceC-ID.Mean)/ID.Mean))/3,
                          SLSumABCDiv3techs = (abs((Snout.lengthA-SL.Mean)/SL.Mean) + 
                                               abs((Snout.lengthB-SL.Mean)/SL.Mean) + 
                                               abs((Snout.lengthC-SL.Mean)/SL.Mean))/3,
                          UJSumABCDiv3techs = (abs((Upper.jaw.lengthA-UJ.Mean)/UJ.Mean) + 
                                               abs((Upper.jaw.lengthB-UJ.Mean)/UJ.Mean) + 
                                               abs((Upper.jaw.lengthC-UJ.Mean)/UJ.Mean))/3,
                          PPSumABCDiv3techs = (abs((Post.orbital.to.PreoperculumA-PP.Mean)/PP.Mean) + 
                                               abs((Post.orbital.to.PreoperculumB-PP.Mean)/PP.Mean) + 
                                               abs((Post.orbital.to.PreoperculumC-PP.Mean)/PP.Mean))/3 )

    #IAE = 1/N Î£ (1/RÎ£ (|Xij - Xj|/ Xj))  sum of all calcs/ 99
    IAE.ID <- round(sum(head99.dat$IDSumABCDiv3techs) / length(head99.dat$IDSumABCDiv3techs) * 100.0,1)  
    IAE.SL <- round(sum(head99.dat$SLSumABCDiv3techs) / length(head99.dat$SLSumABCDiv3techs) * 100.0,1)
    IAE.UJ <- round(sum(head99.dat$UJSumABCDiv3techs) / length(head99.dat$UJSumABCDiv3techs) * 100.0,1)
    IAE.PP <- round(sum(head99.dat$PPSumABCDiv3techs) / length(head99.dat$PPSumABCDiv3techs) * 100.0,1)
    
    # results of IAE
    # print(paste("ID=",format(IAE.ID,1),"SL=",IAE.SL,"UJ=",IAE.UJ,"PP=",IAE.PP))
    
    
```
```{r yisFORKLENGTH}

    lmp <- function (modelobject) {                    #  p value function
           if (class(modelobject) != "lm") stop("Not an object of class 'lm' ")
                 f <- summary(modelobject)$fstatistic
                 p <- pf(f[1],f[2],f[3],lower.tail=F)
                 attributes(p) <- NULL
                 return(p)
    }

    lmslp <- function (modelobject) {                    #  slope (m) value function
             if (class(modelobject) != "lm") stop("Not an object of class 'lm' ")
                 slp <- signif(modelobject$coef[[2]], 5)
                 return(slp)
    }
    
    lmR <- function (modelobject) {                    #  r2 value function
             if (class(modelobject) != "lm") stop("Not an object of class 'lm' ")
                 r2 =  format(summary(modelobject)$r.squared,  digits = 3)
                 return(r2)
    }
    
    
    # y = Fork_Length, response variable
    options("scipen"=100, "digits"=3)
    

```    


<!--chapter:end:index.Rmd-->

# Introduction


<!-- KH: The following chunk of text is an alternative version of the intro. I am implementing some of the changes I suggested below, as well as some additional changes to outline specific objectives. Please feel free to borrow from whatever parts of it you want.  Your original text (with some embedded comments) is still maintained below.


 Biological samples of British Columbia (BC) Sablefish (*Anoplopoma fimbria*) from trap and hook & line fisheries have been collected from a fishery-based voluntary catch sampling program since 1995 [@Haist2001].  Prior to 2018, catch samples were collected dockside from whole fish by Fisheries and Oceans Canada (DFO) port samplers and/or contracted service providers via the dockside monitoring program (DMP). In addition, tagged fish were collected whole from commercial fisheries (trap, trawl, hook & line) at the point of landing also by the dockside monioting program. Biological data collected during catch sampling included fork length and sex. In addition, otoliths were collected and archived for future ageing analyses.  These data provide a fishery-dependent source of age and size composition data for the two-sex age structured operating model used as part of the BC Management Strategy Evaluation (MSE) [@Cox2019, DFO 2020].

 Between 2016 and 2017, DFO undertook research to evaluate the potential to switch to a 'head only' catch sampling program for Sablefish trap and hook & line fisheries.  Head-only sampling allows commercial crew to collect samples directly while at sea, thereby eliminating the need to rely on port samplers for dockside data collection as well as the need for fishing vessels to store whole fish. Instead, commercial crew J-cut the fish at-sea as per commercial practice, view the gonads to determine sex, mark the sex with knife cuts on the operculum, and store the frozen head (and/or floy tag) for later sampling by science personal. The key motivation for switching to a head-only sampling programs was to increase the number and spatial distribution of fishery samples, while simultaneously maintaining the quality of biological data.  

 Length data from commercial fishery catch is a key input to the BC Sablefish operating model (Kendra to add citation), so switching to a head-only sampling program requires the development of methods for obtaining length information using heads, rather than the entire fish.  Previous research on other fish species has shown that lengths can be accurately estimated from head dimensions [@Serafy1996; @Park2007], head and mandible lengths [@Isermann2005], and head height to eye diameter ratio [@Richardson2015]. As part of the 2016 and 2017 studies, we explored relationships between Sablefish fork length and various head morphometric measurements to determine if fork length could be reliably estimated from head measurements. 
 
In this technical report, we describe two research investigations conducted in 2016 and 2017 as part of the evaluation of head-only catch sampling for Sablefish. A brief overview of these two studies is as follows:

1) **Experimental Study - 2016**
The experimental study in 2016 focused on method development for head-only Sablefish sampling using fishery independent survey samples. Six different cranial measurement options were considered and evaluated as part of this study.  Specific objectives were to:
     * Identify which of six different cranial measurements are reliable predictors of fork length based on logistic regression model fits.
     * Evaluate each of the six cranial measurement methods based on ease of use and repeatability for science technicians.
     * Assess the accuracy of sex identification by aquatic science technicians using DNA analysis

2)	**Fishery Pilot Study - 2017**
Following promising preliminary results from the 2016 experimental study, a fishery pilot study was undertaken in 2017 to test the logistics of implementing a head-only sampling program for the commercial fishery.  The pilot study involved commercial fishers collecting head samples while at-sea and recording a sex ID for each sample, followed by scientific sampling of heads on shore.  Two of the cranial measurement options considered in the experimental study were dropped from the pilot study due to challenges identified at that stage. Specific objectives for the fishery pilot study were to:
* Assess ease of sample collection for commercial fishers as well as the condition of collected heads received for at-shore sampling.
* Quantify among-sampler precision for the four different cranial measurements considered using measurements from three different aquatic science technicians.

Methods and results for each of these studies are descibed in detail in the following sections of this report.  Based on favourable results from these studies, the Sablefish catch sampling program switched to a head-only protocol in 2018 (Appendix xx?).
 
 
-->
 
  Biological samples of British Columbia (BC) Sablefish (*Anoplopoma fimbria*) <!--To add: from trap and hook & line fisheries --> have been collected from a fishery-based voluntary catch sampling program since 1995 [@Haist2001]. <!-- Prior to 2018, --> Catch samples were processed <!--KH: could we replace 'processed' with 'collected directly from landed catch' --> by the Department of Fisheries and Oceans (DFO) port samplers and/or contracted service providers. In addition, whole tagged fish were recovered in commercial fisheries (trap, trawl, hook and line) at the point of landing via the dockside monitoring program (DMP) and sampled by Archipelago Marine Research (AMR) <!--KH: why use 'contracted service providers' above and AMR here?  Could we just use 'contracted Science personal' here as well? --> since the early 1990's. 
  

<!--KH suggestion to add:  Biological data collected from both catch and tagging samples typically include length, weight, sex, maturity stage, and otoliths for subsequent ageing. (Lisa - can you confirm that this list is correct?)-->

  These data provide a fishery dependent source of age and size composition data for the two-sex structured operating model of the coastal Management Strategy Evaluation (MSE) [@Cox2019].  <!-- KH suggestion to replace previous sentence with this: These data provide a fishery dependent source of age and size composition data for the two-sex age structured operating model used as part of the BC Management Strategy Evaluation (MSE) [@Cox2019].-->

<!--KH: would also be good to add this more recent reference to the above sentence: https://www.dfo-mpo.gc.ca/csas-sccs/Publications/ScR-RS/2020/2020_025-eng.html -->  
  
  
<!-- KH questions: 
- am I correct in my edit above that the voluntary catch-sampling program is only for H&L and trap since most trawl has (had) mandatory observers collecting samples 
- also - just to confirm ... was port sampling voluntary?  Or, was it just the additional tag recoveries that were voluntary?-->


 The sablefish head-only catch sampling and tagging program began in 2018 in an effort to improve the number of returns from fishers, maintain the quality of the biological data and expand the spatial distribution of samples. Instead of returning whole fish, commercial crew J-cut the fish at-sea as per commercial practice, view the gonads to determine sex, mark the sex with knife cuts on the operculum, and store the frozen head (and/or floy tag) for later sampling by science personal at shore. 
  
  <!--KH: I think it would help to give a bot more up front context on why length is needed --> Previous research on other fish species has accurately estimated lengths from head dimensions [@Serafy1996; @Park2007], head and mandible lengths [@Isermann2005], and head height to eye diameter ratio [@Richardson2015].  In this technical report we expand on previous research and describe the results of 1) the 2016 experimental study of cranial dimensions regressed against fork length; 2) the sampler defined ease of head measurement; 3) DNA sex detection methods; and 4) the compared consistency of the 2017 pilot study head measurements.  <!--KH: I think it would help if the numbered list here linked more to the two studies described below "The 2016 Experimental study and the 2017 pilot study".  I have suggested a way to do this in the alternative intro above. -->
  



 
```{r sampleCount} 

    pointdata    <-  read.csv(paste(path,'figure1.csv',sep=''),header=T)  # read from csv
    females      <-  pointdata[pointdata$SPECIMEN_SEX_DESC=='FEMALE',]
    males        <-  pointdata[pointdata$SPECIMEN_SEX_DESC=='MALE',]

```
  

```{r words_surplus}   

#ORDER OF EVENTS:
#1. 2016 sample sablefish on research surveys, collect bio data and DNA
#2. 2016 head measurements on shore PBS lab, evaluate measurements with 5 point scale
#3. 2016 develop dna sex id by PBS Molecular Genetics lab
#4. 2017 collect head samples on commercial vessel FOS TRIP 338773  Pacific Viking
#5  2017 measure head samples with 3 samplers to develop Index of Average Error
#6. 2017 use DNA to determine fisher sex accuracy

#The at-sea #observer program (ASOP) also collected biological data from the partial at-sea observer coverage (10% of sea days) on commercial trips from 2001 # through to 2005 [@IFMP2001], [@IFMP2004]. 

#In addition, biological samples have been processed by at-sea observers from the offshore seamount fishery that began as an experimental fishery in the 80's [@Murie1996] and moved to a limited-entry #fishery in 2001 [@IFMP2001]. Vessels without an observer have been required to retain a sample of 50/60 frozen sablefish for the department. The service provider Archipelago Marine Research (AMR) has #been responsible for the sablefish tag recovery program since the early 1990's, including the collection and biological sampling of tagged fish.

#   [@Serafy1996]   head measurements regression  on Red Drum fish
#   [@Park2007]  head measurements regression on Brown Croaker
#   [@Isermann2005] head and mandible lengths regression on Walleye
#   [@Richardson2015] ratio of head height to eye diameter regression on New Zealand reef fishes

#  Head morphology showed sexual dimorphism as well [@mesa2005].

#  Morphometric characters  [@]
# The statistical relationship between total length (TL) and total body weight (W) of the fish was derived using the formula:
# log W = log a + b log TL  
# Where, W is the weight of fish (g); a is the intercept (constant); TL is
# the total length of fish (cm) and b is the regression coefficient (slope).


 
```

<!--chapter:end:01_introduction.Rmd-->

# Methods

<!-- KH: Within the methods, suggestion consider adding sub-headings to the methods for each study for 'Data Collection' and 'Analysis'-->

##  Experimental Study 2016

<!-- New header ?: 
### Data Collection 
-->

Sablefish were randomly selected for sampling during the 2016 biennial DFO Groundfish Synoptic Bottom Trawl surveys, following a length stratified protocol. A tally <!--KH: use 'total' instead of 'tally' ?--> of 212 fish were sampled on the West Coast Vancouver Island survey [@Williams2018] and 219 fish were sampled<!--KH: suggestion to delete text 'were sampled'--> on the West Coast Haida Gwaii survey [@Nottingham2018]. In addition, seven small sablefish were collected during the 2016 salmon survey (put reference here) (Figure \@ref(fig:figure1)). <!--KH: At present, the salmon survey is in Figure 1 legend, but no pink points on map. Is the plan still to add that to the map?  Or, you could put a description here of what parts of the coast the salmon survey sampled? -->

For each selected fish, fork length, round weight, sex and maturity were recorded at sea. The heads were removed, labelled <!--KH: labelled with a unique ID?-->and frozen.  On shore, the cranial dimensions of upper jaw (L~UJ~), eye diameter (L~ED~), interorbital distance ( L~ID~), snout length (L~SL~), post orbital to preoperculum distance (L~PP~) and post orbital head length (L~PO~) were measured using Mitutoyo AbsoluteÂ® 500-762-20 coolant proof digimatic calipers (Table \@ref(tab:table1), Appendix \@ref(app:first-appendix)).  Sagittal otoliths were collected for future ageing.  <!--KH: Suggestion to move the following sentence to a seperate 'Analysis' section: Fork lengths (L~FL~) were estimated by a simple linear regression model, using the cranial measurements as a predictor variables.-->  

At the time of sampling, each cranial dimension was evaluated by experienced samplers <!--KH: how many samplers? Was there repeat measurements at this stage? Or, was is one sampler per fish with different samplers doing different fish -->on a five point rating scale in terms of two distinct criteria: 1. ease of use and 2. repeatability. The ease of use metric focused on three key attributes of the measurement learn-ability (task understanding), efficiency (task-completion time) and degree of difficulty (task performance ease).  The repeatability metric focused on ranking each measurement under repeated caliper placement, taking into consideration the soft and hard head tissues <!--KH: What does 'taking into consideration hard and soft tissues mean? -->. 
<!--KH: would help to standardize terms criteria, attribute, and metric above. -->


<!-- KH: Suggested alternative version of above paragraph:

As part of the sampling protocol, samplers scored each of the six cranial dimensions on two different attributes: 1. ease of use and 2. repeatability.  A five-point scale was used to score each attribute. When scoring 'ease of use', samplers were asked to consider learn-ability (i.e., how easy was it to understand the task), efficiencieny (i.e., task completion time), and degree of difficulty (i.e., ease of performing the task).  When scoring 'repeatability', samplers were asked to take repeated measurements of each cranial dimension and assign a score based on the consistency in each measurement under repeated caliper placement.

-->


Operculum clips (DNA) were collected from the first 137 fish measured (79 male and 58 female <!--KH; Are these numbers based on the sex assignments of the samplers? Or, are these DNA results? -->) and forwarded to the Molecular Genetics Laboratory (MGL) for analysis and gender test development.


### Molecular Genetics Laboratory (MGL) genetic sex-determination

<!--KH: Is it possible to add a bit more context into this section?  i.e., molecular genetic analyses were used to determine sex for 137 samples collected during the Experimental Study.  DNA-based sex assignments were then compared with the sex assigned by samplers through their visual inspection of the gonads to determine the  accuracy of science staff at identifying Sablefish sex.-->

DNA multiplex polymerase chain reactions (PCRs) were conducted using fluorescently labelled forward primers.	X-insert and Y-insert specific primers developed by @Rondeau2013 were used, but the X-insert forward and Y-nested reverse were redesigned to produce slightly smaller PCR products (Table \@ref(tab:table2)).   Sex specific alleles were size fractionated in an ABI 3730 capillary DNA analyzer and were scored with ABI GeneMapper using an internal lane sizing standard. 



<!-- New header ?: 
### Data Analysis
KH: Moved the follwing sentence from above here:
Fork lengths (L~FL~) were estimated by a simple linear regression model, using the cranial measurements as a predictor variables.

## KH: Also, is it also possible to add a couple more sentences to this analysis section?  This could include re-iterating why the regression was done (i.e., to determine how well each of the six candidate cranial measurements could predict fork length).  You could also include a bit more info on linear regressions (i.e., package in R that was used, how you assessed model fit)

-->



## Pilot study 2017 
<!-- KH: Change this header to 'Fishery Pilot Study 2017'? 
-- I like the addition of the word 'Fishery' because it helps identify that commercial fishers were part of this study. Thoughts??  -->

<!-- New header ?: 
### Data Collection
-->

In 2017, a pilot study was conducted with the commercial sector returning sablefish head-only samples.  A total of 360 heads were collected from J-cut sablefish on a limited-entry fishery trip to the Cobb and Eickelberg seamounts (Figure \@ref(fig:figure1)).  Each operculum was marked by commercial fishers with either one knife cut (male) or two knife cuts (female) (Appendix \@ref(app:second-appendix)).  

Scientific sampling occurred on shore, with the first 99 heads of the pilot study measured by three samplers for L~ID~, L~SL~, L~UJ~ and L~PP~.  <!--KH: Why were just these four used instead of original 6? Was is based on preliminary results from the Experimental Study? i.e., there was an early decision that these 4 were most promising? -->

<!--KH: could also add 'Three different samplers were used at this stage of the Fishery Pilot Study to better quantify the repeatability cranial head measurements -->



<!-- New header ?: 
### Data Analysis
-->


Given that three highly experienced technicians were used to conduct the same measurements of the each head morphometric, the Index of Average Error (IAE) (Beamish 1981 <!--KH: note that Beamish 1981 is not in refs. Can you please send it to me so I can have a quick look at it to make sure I'm understanding correctly?  Is it this paper: https://cdnsciencepub.com/doi/pdf/10.1139/f81-132?-->) was calculated to find the most consistent cranial measurement. It is defined as:
$$
IAE=\frac{1}{N}\sum_{j = 1}^{N}\left[\frac{1}{R}\sum_{i = 1}^{R}\frac{ - X_j|}{X_j}\right]
$$
<!--KH: what is the addition | symbol after X_j in the numerator mean?? -->

where N is the number of sablefish measured for each cranial measurement, R is the number of times each cranial measurement was taken, $X_{ij}$ is the average cranial length for the jth sablefish, and $X_{ij}$ is the ith cranial measurement of the jth sablefish.

<!--KH: Note that in equation, you just use X_i, but in text, you denote variables as X_i,j.  Is the neccesary correction to change the equation so that X_j becomes X_{i,j}??  In this case, I think you would describe variables in text as "$X_{ij}$ is the cranial length measurement of the jth sablefish taken by the ith sampler"  Is this right?-->


<!-- KH: It would also be helpful to include a brief description of what IAE represents (is it a measure of precision??), which I can help with if you like-->

Fin clips (95 of 99) were forwarded to the molecular genetics lab for an audit of fisher sex determination. 

<!--chapter:end:02_methods.Rmd-->

# Results

```{r fishData}

    fish         <-   read.csv(paste(path,"head_measurements.csv",sep=""), header = T)  # master data
    males        <-   fish[which(fish$SPECIMEN_SEX_DESC=='MALE'),]
    count.males  <-   length(males$SPECIMEN_ID)
    females      <-   fish[which(fish$SPECIMEN_SEX_DESC=='FEMALE'),]
    count.females<-   length(females$SPECIMEN_ID)
    fish.min     <-   min(fish$Fork_Length)
    fish.max     <-   max(fish$Fork_Length)
    fish.avg     <-   mean(fish$Fork_Length)
    
```
```{r head.stats}

    hd                     <-  hdUj[hdUj$SPECIMEN_SEX_DESC=='FEMALE',]        # UPPER JAW: female table of sample size, mean and sd for variables
    sex                    <-  'female'
    fl.nme                 <-  "Fork length"
    n                      <-  length(hd$SPECIMEN_ID)                   
    mn                     <-  round(mean(hd$Upper_jaw_length),1)
    mnfl                   <-  round(mean(hd$Fork_Length),1)
    std                    <-  round(sd(hd$Upper_jaw_length),2)
    stdfl                  <-  round(sd(hd$Fork_Length),2)
    slope                  <-  round(lmslp(lm(Fork_Length ~ Upper_jaw_length, data=hd)),1)
    se                     <-  round(coef(summary(lm(Fork_Length ~ Upper_jaw_length, data=hd)))[,"Std. Error"][2],2)  # se should be one more decimal place than for what 
    r2                     <-  format(summary(lm(Fork_Length ~ Upper_jaw_length, data=hd))$r.squared,  digits = 3)    # they are computed for
    r                      <-  format(cor(hd$Upper_jaw_length,hd$Fork_Length),  digits = 3) 
    measurement            <-  "UJ"
    name                   <-  "upper jaw length"
    mf.uj                  <-  lm(Fork_Length ~ Upper_jaw_length, data=hd)
    
    head.stats <- data.frame(measurement = character(),
                             sex = character(),
                             n     = integer(),
                             slope = double(),
                             se    = double(),
                             r2    = double(),
                             r     = double(),
                             mn    = double(), 
                             std   = double(),
                             mnfl  = double(),
                             stdfl = double(),
                             name  = character(),
                             stringsAsFactors = FALSE)
    
    head.stats[1,]    <-  c(measurement,sex, n, slope, se, r2, r, mn, std,  mnfl, stdfl, name )
    
    hd                     <-  hdUj[hdUj$SPECIMEN_SEX_DESC=='MALE',]          #UPPER JAW: male table of sample size, mean and sd for variables
    sex                    <-  'male'
    n                      <-  length(hd$SPECIMEN_ID)                   
    mn                     <-  round(mean(hd$Upper_jaw_length),1)
    mnfl                   <-  round(mean(hd$Fork_Length),1)
    std                    <-  round(sd(hd$Upper_jaw_length),2)
    stdfl                  <-  round(sd(hd$Fork_Length),2)
    mm.uj                  <-  lm(Fork_Length ~ Upper_jaw_length, data=hd)
    
    head.stats[2,] <- c("UJ", sex, n,
                       slope=round(lmslp(lm(Fork_Length ~ Upper_jaw_length, data=hd)),1),
                       se=round(coef(summary(lm(Fork_Length ~ Upper_jaw_length, data=hd)))[, "Std. Error"][2],2),
                       r2=format(summary(lm(Fork_Length ~ Upper_jaw_length, data=hd))$r.squared,  digits = 3),
                       r=format(cor(hd$Upper_jaw_length,hd$Fork_Length),  digits = 3), 
                       mn, std,  mnfl, stdfl,"upper jaw length")
    
    head.stats$measurement  <- as.character(head.stats$measurement)
    #typeof(head.stats$measurement)
    
    hd                     <-  hdEd[hdEd$SPECIMEN_SEX_DESC=='FEMALE',]        #EYE DIAMETER: female table of sample size, mean and sd for variables
    sex                    <-  'female'
    n                      <-  length(hd$SPECIMEN_ID)                   
    mn                     <-  round(mean(hd$Eye_Diameter),1)
    mnfl                   <-  round(mean(hd$Fork_Length),1)
    std                    <-  round(sd(hd$Eye_Diameter),2)
    stdfl                  <-  round(sd(hd$Fork_Length),2)
    mf.ed                  <-  lm(Fork_Length ~ Eye_Diameter, data=hd)    
    
    head.stats[3,] <- c("ED", sex,n,
                       slope=round(lmslp(lm(Fork_Length ~ Eye_Diameter, data=hd)),1),
                       se=round(coef(summary(lm(Fork_Length ~ Eye_Diameter, data=hd)))[, "Std. Error"][2],2),
                       r2=format(summary(lm(Fork_Length ~ Eye_Diameter, data=hd))$r.squared,  digits = 3),
                       r=format(cor(hd$Eye_Diameter,hd$Fork_Length),  digits = 3), 
                       mn, std,  mnfl, stdfl, "eye diameter")
    
    hd                     <-  hdEd[hdEd$SPECIMEN_SEX_DESC=='MALE',]        #EYE DIAMETER: male table of sample size, mean and sd for variables
    sex                    <-  'male'
    n                      <-  length(hd$SPECIMEN_ID)                   
    mn                     <-  round(mean(hd$Eye_Diameter),1)
    mnfl                   <-  round(mean(hd$Fork_Length),1)
    std                    <-  round(sd(hd$Eye_Diameter),2)
    stdfl                  <-  round(sd(hd$Fork_Length),2)
    
    head.stats[4,] <- c("ED", sex,n,
                       slope=round(lmslp(lm(Fork_Length ~ Eye_Diameter, data=hd)),1),
                       se=round(coef(summary(lm(Fork_Length ~ Eye_Diameter, data=hd)))[, "Std. Error"][2],2),
                       r2=format(summary(lm(Fork_Length ~ Eye_Diameter, data=hd))$r.squared,  digits = 3),
                       r=format(cor(hd$Eye_Diameter,hd$Fork_Length),  digits = 3), 
                       mn, std,  mnfl, stdfl, "eye diameter")  

  
    
    hd                     <-  hdId[hdId$SPECIMEN_SEX_DESC=='FEMALE',]      # INTERORBITAL DISTANCE: female table of sample size, mean and sd for variables
    sex                    <-  'female'
    n                      <-  length(hd$SPECIMEN_ID)                   
    mn                     <-  round(mean(hd$InterOrbital_Distance),1)
    mnfl                   <-  round(mean(hd$Fork_Length),1)
    std                    <-  round(sd(hd$InterOrbital_Distance),2)
    stdfl                  <-  round(sd(hd$Fork_Length),2)
  
    head.stats[5,] <- c("ID", sex,n,
                       slope=round(lmslp(lm(Fork_Length ~ InterOrbital_Distance, data=hd)),1),
                       se=round(coef(summary(lm(Fork_Length ~ InterOrbital_Distance, data=hd)))[, "Std. Error"][2],2),
                       r2= format(summary(lm(Fork_Length ~ InterOrbital_Distance, data=hd))$r.squared,  digits = 2),
                       r=format(cor(hd$InterOrbital_Distance,hd$Fork_Length),  digits = 2), 
                       mn, std,  mnfl, stdfl,"interorbital distance")
    
    hd                     <-  hdId[hdId$SPECIMEN_SEX_DESC=='MALE',]       # INTERORBITAL DISTANCE: male table of sample size, mean and sd for variables
    sex                    <-  'male'
    n                      <-  length(hd$SPECIMEN_ID)                   
    mn                     <-  round(mean(hd$InterOrbital_Distance),1)
    mnfl                   <-  round(mean(hd$Fork_Length),1)
    std                    <-  round(sd(hd$InterOrbital_Distance),2)
    stdfl                  <-  round(sd(hd$Fork_Length),2)
  
    head.stats[6,] <- c("ID", sex,n,
                       slope=round(lmslp(lm(Fork_Length ~ InterOrbital_Distance, data=hd)),1),
                       se=round(coef(summary(lm(Fork_Length ~ InterOrbital_Distance, data=hd)))[, "Std. Error"][2],2),
                       r2= format(summary(lm(Fork_Length ~ InterOrbital_Distance, data=hd))$r.squared,  digits = 3),
                       r=format(cor(hd$InterOrbital_Distance,hd$Fork_Length),  digits = 3),
                       mn, std,  mnfl, stdfl,"interorbital distance")
    
    
    hd                     <-  hdSl[hdSl$SPECIMEN_SEX_DESC=='FEMALE',]     # SNOUT LENGTH: female table of sample size, mean and sd for variables
    sex                    <-  'female'
    n                      <-  length(hd$SPECIMEN_ID)                   
    mn                     <-  round(mean(hd$Snout_length),1)
    mnfl                   <-  round(mean(hd$Fork_Length),1)
    std                    <-  round(sd(hd$Snout_length),2)
    stdfl                  <-  round(sd(hd$Fork_Length),2)
  
    head.stats[7,] <-c("SL", sex,n,
                      slope=round(lmslp(lm(Fork_Length ~ Snout_length, data=hd)),1),
                      se=round(coef(summary(lm(Fork_Length ~ Snout_length, data=hd)))[, "Std. Error"][2],2),
                      r2= format(summary(lm(Fork_Length ~ Snout_length, data=hd))$r.squared,  digits = 3),
                      r=format(cor(hd$Snout_length,hd$Fork_Length),  digits = 3),
                      mn, std,  mnfl, stdfl,"snout length")
    
    hd                     <-  hdSl[hdSl$SPECIMEN_SEX_DESC=='MALE',]     # SNOUT LENGTH: male table of sample size, mean and sd for variables
    sex                    <-  'male'
    n                      <-  length(hd$SPECIMEN_ID)                   
    mn                     <-  round(mean(hd$Snout_length),1)
    mnfl                   <-  round(mean(hd$Fork_Length),1)
    std                    <-  round(sd(hd$Snout_length),2)
    stdfl                  <-  round(sd(hd$Fork_Length),2)
  
    head.stats[8,] <-c("SL", sex,n,
                      slope=round(lmslp(lm(Fork_Length ~ Snout_length, data=hd)),1),
                      se=round(coef(summary(lm(Fork_Length ~ Snout_length, data=hd)))[, "Std. Error"][2],2),
                      r2= format(summary(lm(Fork_Length ~ Snout_length, data=hd))$r.squared,  digits = 3),
                      r=format(cor(hd$Snout_length,hd$Fork_Length),  digits = 3),
                      mn, std,  mnfl, stdfl, "snout length")
    
    hd                     <-  hdPop[hdPop$SPECIMEN_SEX_DESC=='FEMALE',]    #POSTORBITAL PREOPERCULUM: female table of sample size, mean and sd for variables
    sex                    <-  'female'
    n                      <-  length(hd$SPECIMEN_ID)                   
    mn                     <-  round(mean(hd$Postorbital_Preoperculum),1)
    mnfl                   <-  round(mean(hd$Fork_Length),1)
    std                    <-  round(sd(hd$Postorbital_Preoperculum),2)
    stdfl                  <-  round(sd(hd$Fork_Length),2)

    head.stats[9,] <- c("PP",sex,n,
                       slope=round(lmslp(lm(Fork_Length ~ Postorbital_Preoperculum, data=hd)),1),
                       se=round(coef(summary(lm(Fork_Length ~ Postorbital_Preoperculum, data=hd)))[, "Std. Error"][2],2),
                       r2=format(summary(lm(Fork_Length ~ Postorbital_Preoperculum, data=hd))$r.squared,  digits = 3),
                       r=format(cor(hd$Postorbital_Preoperculum,hd$Fork_Length),  digits = 3),
                       mn, std,  mnfl, stdfl,"postorbital preoperculum length")

    hd                     <-  hdPop[hdPop$SPECIMEN_SEX_DESC=='MALE',]    #POSTORBITAL PREOPERCULUM: male table of sample size, mean and sd for variables
    sex                    <-  'male'
    n                      <-  length(hd$SPECIMEN_ID)                   
    mn                     <-  round(mean(hd$Postorbital_Preoperculum),1)
    mnfl                   <-  round(mean(hd$Fork_Length),1)
    std                    <-  round(sd(hd$Postorbital_Preoperculum),2)
    stdfl                  <-  round(sd(hd$Fork_Length),2)

    head.stats[10,] <- c("PP",sex,n,
                       slope=round(lmslp(lm(Fork_Length ~ Postorbital_Preoperculum, data=hd)),1),
                       se=round(coef(summary(lm(Fork_Length ~ Postorbital_Preoperculum, data=hd)))[, "Std. Error"][2],2),
                       r2=format(summary(lm(Fork_Length ~ Postorbital_Preoperculum, data=hd))$r.squared,  digits = 3),
                       r=format(cor(hd$Postorbital_Preoperculum,hd$Fork_Length),  digits = 3),
                       mn, std,  mnfl, stdfl,"postorbital preoperculum length")  
    
    hd                     <-  hdPo[hdPo$SPECIMEN_SEX_DESC=='FEMALE',]    #POSTORBITAL HEAD LENGTH: female table of sample size, mean and sd for variables
    sex                    <-  'female'
    n                      <-  length(hd$SPECIMEN_ID)                   
    mn                     <-  round(mean(hd$Post_orbital_Head_length),1)
    mnfl                   <-  round(mean(hd$Fork_Length),1)
    std                    <-  round(sd(hd$Post_orbital_Head_length),2)
    stdfl                  <-  round(sd(hd$Fork_Length),2)

    head.stats[11,] <- c("PO",sex,n,
                       slope=round(lmslp(lm(Fork_Length ~ Post_orbital_Head_length, data=hd)),1),
                       se=round(coef(summary(lm(Fork_Length ~ Post_orbital_Head_length, data=hd)))[, "Std. Error"][2],2),
                       r2=format(summary(lm(Fork_Length ~ Post_orbital_Head_length, data=hd))$r.squared,  digits = 3),
                       r=format(cor(hd$Post_orbital_Head_length,hd$Fork_Length),  digits = 3),
                       mn, std,  mnfl, stdfl, "postorbital head length")

    hd                     <-  hdPo[hdPo$SPECIMEN_SEX_DESC=='MALE',]    #POSTORBITAL HEAD LENGTH: male table of sample size, mean and sd for variables
    sex                    <-  'male'
    n                      <-  length(hd$SPECIMEN_ID)                   
    mn                     <-  round(mean(hd$Post_orbital_Head_length),1)
    mnfl                   <-  round(mean(hd$Fork_Length),1)
    std                    <-  round(sd(hd$Post_orbital_Head_length),2)
    stdfl                  <-  round(sd(hd$Fork_Length),2)

    head.stats[12,] <- c("PO",sex,n,
                       slope=round(lmslp(lm(Fork_Length ~ Post_orbital_Head_length, data=hd)),1),
                       se=round(coef(summary(lm(Fork_Length ~ Post_orbital_Head_length, data=hd)))[, "Std. Error"][2],2),
                       r2=format(summary(lm(Fork_Length ~ Post_orbital_Head_length, data=hd))$r.squared,  digits = 3),
                       r=format(cor(hd$Post_orbital_Head_length,hd$Fork_Length),  digits = 3),
                       mn, std,  mnfl, stdfl, "postorbital head length") 
    
    top.fish        <- head.stats %>% group_by(sex) %>% slice_max(order_by = r, n = 2)   # get top 2 r  values male and female
    
    
    
    
    
```

##  Experimental Study 2016
  
A total of 438 specimens comprising `r count.males` males and `r count.females` females were evaluated for this study.  The smallest fork length of the collected specimens was `r fish.min` mm, the largest was `r fish.max` mm, and the average was `r round(fish.avg,1)` mm (Table \@ref(tab:table3)).  The post orbital head length (L~PO~) measurement was abandoned after testing 130 sablefish due to low sample quality and technical issues.  

Table \@ref(tab:table4) lists the statistics of the cranial dimensions (L~UJ~, L~ED~, L~ID~, L~SL~, L~PP~, L~PO~) as predictors of the response variable fork length (L~FL~).  All cranial dimensions were highly correlated with fork length (Figure \@ref(fig:figure2) and Figure \@ref(fig:figure3)).  The correlation coefficient (r) was highest for female measurements of `r top.fish$name[1]` (`r top.fish$r[1]`) and  `r top.fish$name[2]` (`r top.fish$r[2]`) and male measurements of `r top.fish$name[3]` (`r top.fish$r[3]`) and  `r top.fish$name[4]` (`r top.fish$r[4]`).  <!--KH: Could also highlight the linear regression results here, including the high R-sq values and the highly significant p-values. These results are likely more relevant going forwards as we will be using the linear regression equation to predict fork length from head measurements rather than the correlation results.-->

The aquatic science research technicians scored interorbital distance (L~ID~) as the highest on the five point scale for ease of use and repeatable criteria, and eye diameter (L~ED~) and postorbital head length (L~PO~) were scored as the lowest (Table \@ref(tab:table5)).  L~ID~ (narrowest distance between the eye sockets) proved the easiest measurement as the tissue could be easily compressed with the caliper jaws to obtain bone measurements.  L~ED~ (anterior-posterior diameter of eye socket) proved hard to repeat on soft tissue and L~PO~ (posterior inner edge of orbit to dorsal insertion of opercle) was difficult to measure since many opercula were damaged during head removal by J-cut.  

### Molecular Genetics Laboratory (MGL) genetic sex-determinations

Genomic DNA (130 of 137 fin clips) were successfully PCR amplified to determine sex.  The accuracy of sex detection by the science technicians was 92% (119/130). 

##  Pilot study 2017

The 360 heads received from the commercial vessel were in good condition and operculum cuts worked well to indicate sex. The first 99 heads (`r count99[1]` from Cobb Seamount, `r count99[2]` from Eikelberg seamount) were measured once by three expert science technicians for each cranial dimension of L~UJ~, L~ID~, L~SL~ and L~PP~ (Table \@ref(tab:table6)).  The cranial dimensions of L~ED~ and L~PO~ were eliminated after the results from the 2016 experimental study <!--KH: this last sentence about two methods eliminated should be moved up to methods instead of here. I have a comment about this in the methods chapter -->. The cranial measurements that produced the lowest mean error were upper jaw (L~UJ~) and interorbial distance (L~ID~) with IAE values of `r IAE.UJ` % and `r IAE.ID` %, respectively (Table \@ref(tab:table6)). The accuracy of the commercial fisher sex detection from the DNA gender analysis was xx% (x/95).





<!--chapter:end:03_results.Rmd-->

# Discussion

All cranial dimensions collected in the research investigation were found to be good predictors of sablefish fork length (L~FL~) with resulting r^2^ values for male and female sablefish >0.88.  However, the catch sampling program implemented the interorbital distance (L~ID~) length measurement as the new standard based on feedback from the experienced technicians.  This measurement could be performed quickly, accurately and repeatedly.  In general, they reported measurement errors were more probable when the calipers were placed on soft tissues, rather than bone.  Other errors were a result of the manner in which the sablefish were handled before measurement, ie. the operculum was cut off.  Samplers also reported that the smaller sablefish placed limitations on performing cranial measurements.  Future studies could expand the size range to include small fish to determine those factors that influence predictions of L~FL~.  During this phase of the research investigation, the Pacific Biological Station Molecular Genetics Laboratory successfully developed a genetic protocol to determine sex.

The pilot commercial fishing trip for collection of sablefish heads returned high quality samples and fishers were successful in fish sex determinations (I hope x %).  These pilot samples were measured by three experienced technicians using a standardized protocol that determined  L~UJ~ and L~ID~ had lower average errors over L~SL~ and L~PP~.  This matched the comments on the  difficulty in caliper jaw positioning during the L~SL~ and L~PP~ measurements.  Success with this pilot may be useful for other species such as Pacific halibut who experience predation problems on longline surveys, or difficult to measure deep water species.

As a result of our study, routine biological sampling procedures in 2018 were modified so that commercial fisheries are now only returning head samples, rather than the entire fish. These changes have improved the fishers ability to freeze, store and transport samples.    We recommend that a follow-up review in a couple years to better examine how sampling rates, length composition and spatial distribution have changed to improve our overall data confidence.


```{r figureComposition,  results='asis',  out.width = "410px", out.height = "400px",fig.align='left'}

    #However, our overall goals were also intended to expand spatial distribution of samples and increase the number of samples.  
    #Unfortunately, these goals were not met given sampling challenges caused by COVID restrictions that began in early 2020.  
    #Now that travel restrictions are being lifted we are hopeful that our sampling coverage will expand improving our overall data confidence.  
    
   
    #png("C:/github/sablehead/figures/FigureDiscussion.png", units="px", width=1600, height=1800, res=150) # write png to file

    # did we get bigger fish returned from the fishery after 2018 -- nope because of all the baby sablefish that flooded the fishery
    #   Recruitment is one of the dominant processes regulating fish population productivity
     library(dplyr)
     samples  <- paste(" SELECT TRIP_SUB_TYPE_CODE, TRIP_SUB_TYPE_DESC, [trip year], fishing_year,   ",
                       " dbo.ll_SableFishingYearNo(fishing_year) AS fynum, ",
		                   " SPECIMEN_ID, SAMPLE_ID, SPECIMEN_SEX_CODE, Fork_Length, SPECIMEN_AGE  ",
		                   " FROM  dbo.GENERIC_GFBIO_COMMERCIAL_SPECIMENS_LWSMO  ",
		                   " WHERE (Fork_Length >0)  AND  ([trip year] > 2015)   ",
                       " AND (SPECIMEN_AGE IS NULL) " , sep='')  

    #specimens     <- GetSQLData(samples ,"Sablefish")
    #write.table( specimens, file = paste(path,"CommSpecimensCY.csv",sep=''),row.names=FALSE, na="",col.names=TRUE, sep=",")
    specimens     <-  read.csv(paste(path,"CommSpecimensCY.csv", sep=''), header=T) # read from csv
    # print(head(specimens))
    specimens  <- specimens %>%  mutate(GR = ifelse(fishing_year %in% c('FY 2016/2017','FY 2017/2018'), 1, 2))
    
    specimens.before  <-  specimens[specimens$GR==1,]
    a                 <-  specimens.before[specimens.before$Fork_Length>=550,]
    legal.before      <-  length(a$Fork_Length)/length(specimens.before$Fork_Length)  # 44%  count of big fish/ total fish pre2018 
        
    specimens.after   <-  specimens[specimens$GR==2,]
    b  <- specimens.after[specimens.after$Fork_Length>=550,]
    legal.after<-  length(b$Fork_Length)/length(specimens.after$Fork_Length)   # 13% count of big fish/ total fish post 2108

    #unique(specimens$fishing_year)   # indicates the fishing years
    #print(legal.before)
    #print(legal.after)
    
      gear.samples  <- paste(" SELECT  TRIP_SUB_TYPE_CODE, TRIP_SUB_TYPE_DESC, [trip year], fishing_year, ",
                             " dbo.ll_SableFishingYearNo(fishing_year) AS fynum, SPECIMEN_ID, SAMPLE_ID, ",
                             " SPECIMEN_SEX_CODE, Fork_Length, SPECIMEN_AGE,  GEAR_DESC ",
                             " FROM  dbo.GENERIC_GFBIO_COMMERCIAL_SPECIMENS_LWSMO ",
                             " WHERE  (Fork_Length > 0) AND ([trip year] > 2015)" , sep='')  

    #gear.specimens     <- GetSQLData(gear.samples ,"Sablefish")
    #write.table( gear.specimens, file = paste(path,"GearCommSpecimensCY.csv",sep=''),row.names=FALSE, na="",col.names=TRUE, sep=",")
    gear.specimens     <-  read.csv(paste(path,"GearCommSpecimensCY.csv", sep=''), header=T) # read from csv
    #print(head(gear.specimens))
    
     # sex in(1,2) only  for calendar years, 2020 only has 6 so left out  
     gear.fishery <- gear.specimens[gear.specimens$SPECIMEN_SEX_CODE %in% c(1,2) & gear.specimens$trip.year != 2020,]
                           # previous query: all fishing years Levels: FY 2016/2017 FY 2017/2018 FY 2018/2019 FY 2019/2020
                           # & gear.specimens$fynum %in% c(12,13,14,15),]

     # group data into 5 cm intervals    
     gear.fishery <- gear.fishery %>% mutate(lengthcm = 
			         cut(Fork_Length/10, breaks=seq(0, 100,by=5)))  
     names(gear.fishery)  <- c("TRIP_SUB_TYPE_CODE" ,"TRIP_SUB_TYPE_DESC" ,"trip.year" ,  "fishing_year" , "fynum"  ,
                               "SPECIMEN_ID" ,  "SAMPLE_ID" , "sex" , "Fork_Length" ,  "SPECIMEN_AGE" ,
                               "GEAR_DESC" , "lengthcm"  )
   
   library(plyr)  # mean, standard deviation and count
   df.text<-ddply( gear.fishery,.(trip.year, sex),summarise,
                                   mean.value= round(mean(Fork_Length)/10,1) ,
                                   stdev.value =  round(sd(Fork_Length)/10,1)   , 
                                   count.value = length(SPECIMEN_ID))
 

   p <- ggplot( gear.fishery, aes(x = lengthcm)) +
         #ggtitle("commercial length composition") +
         geom_histogram(aes(color = as.factor(sex),
                 	                     fill = as.factor(sex)), 
                 	                     stat="count",  position = "identity",alpha = 0.3)     +
                                       scale_fill_manual(values = c("#00AFBB", "#E7B800")) +
                                       scale_color_manual(values = c("#00AFBB", "#E7B800")) +
        geom_vline(xintercept = 5.5, col="red",  linetype="dashed")  +
        theme(axis.text.x = element_text(angle = 90)) 

   p2<-p + facet_wrap(~trip.year) + 
        geom_text(data=df.text,aes(label=paste(" n=",count.value), 
                                  color = as.factor(sex), x=-Inf,y=Inf), 
                                  size = 2.5, hjust=-0.1, vjust=c(6,8,6,8,6,8,6,8)) +
        geom_text(data=df.text,aes(label = paste("mean=", mean.value ) , 
                                  color = as.factor(sex), x=-Inf,y=Inf), 
                                  size = 2.5, hjust=-0.9, vjust=c(6,8,6,8,6,8,6,8))   +
        geom_text(data=df.text,aes(label=paste("SD=", stdev.value ), 
                                  color = as.factor(sex), x=-Inf,y=Inf), 
                                  size = 2.5, hjust=-2.9, vjust=c(6,8,6,8,6,8,6,8) )
   
    # while (!is.null(dev.list()))  dev.off()
    # img <-   paste('C:/github/sablehead/figures/figureDiscussion.png',sep="")   # -- retrieve png 
    #          knitr::include_graphics(img)
    

```

# Acknowledgments

We thank Schon Acheson and Kristina Castle for lending their skilled technical expertise for this report.  We also thank the Molecular Genetics Laboratory at PBS for developing a sablefish gender test. A special thanks to the crew of the Pacific Viking for participating in the pilot project.

\clearpage

<!--chapter:end:04_discussion.Rmd-->

# Tables

(ref:Table1Caption) List of head dimensions for upper jaw length (L~UJ~), eye diameter (L~ED~), interorbital distance (L~ID~), snout length (L~SL~), post orbital to preoperculum distance (L~PP~) and post orbital head length (L~PO~) measurement descriptions and specification of caliper jaw placement.  Many follow the morphological measurements described in [@Shaw1997].  The matching images are found in Appendix A.
\ \
\ \ 

```{r table1, echo=FALSE}
     options(knitr.kable.NA = '')
     df   <-  read.csv(paste(path,"Table1.csv", sep=""), header=T)
     
     df$symbol  <-  c(paste("L", "\\textsubscript{UJ}", sep=''),
                      paste("L", "\\textsubscript{ED}", sep=''),
                      paste("L", "\\textsubscript{ID}", sep=''),
                      paste("L", "\\textsubscript{SL}", sep=''),
                      paste("L", "\\textsubscript{PP}", sep=''),
                      paste("L", "\\textsubscript{PO}", sep=''))
     df$Head.dimension  <- NULL
     df  <- df[,c(3,1,2)]
     names(df)  <- c("Head dimension","Head description","Caliper jaw position")
     

     # Change to names of my local images
     #df$Image = c(paste(graph_directory,'ca.png',sep=''),
      #            paste(graph_directory,'Figure2b.png',sep=''),
      #            paste(graph_directory,'Figure2c.png',sep=''),
      #            paste(graph_directory,'Figure2d.png',sep=''),
      #            paste(graph_directory,'Figure2e.png',sep=''),
      #            paste(graph_directory,'Figure2f.png',sep=''))
     
     # Add appropriate rmarkdown tagging
     #df$Image <- sprintf('![](%s){width=50px}', df$Image)
     
     kableExtra::kable(df, booktabs = TRUE, 
                       linesep = "", format = "latex",
                       escape = F, # allows textsuperscript latex
                       caption = "(ref:Table1Caption)") %>%
     
     
     kableExtra::kable_styling(font_size = 10, position = "left",latex_options = "hold_position") %>%
                       column_spec(1, width  = "1.9cm") %>%
                       column_spec(2, width  = "6.0cm") %>%
                       column_spec(3, width  = "7.5cm") %>%
                       row_spec(0, bold="true") %>%
                       row_spec(1,  hline_after = T) %>%
                       row_spec(2,  hline_after = T) %>%
                       row_spec(3,  hline_after = T) %>%
                       row_spec(4,  hline_after = T) %>%  
                       row_spec(5,  hline_after = T) 
```
\ \
\ \
\ \
(ref:Table2Caption) Primers used in the development of a genetic test for determining sablefish sex, developed by the Pacific Biological Station (PBS) Molecular Genetics Laboratory (MGL).
\ \
\ \
```{r table2,  results="asis",echo=FALSE, warning=FALSE, message=FALSE}

   dna <- read.csv(paste(path,'Table2.csv',sep=''),header=T)  # read from csv
   names(dna)<- c("Locus","Sequence","Fragment Size")
   
   kableExtra::kable(dna, booktabs = TRUE,
                     format = "latex",
                     caption = "(ref:Table2Caption)") %>%
   
   kableExtra::kable_styling(font_size = 10, position = "left",latex_options = "hold_position") %>%
                     row_spec(0, bold="true") 
   

```
\clearpage

(ref:Table3Caption) Summary of sablefish biological data collected during the 2016 experimental study. Tally of fork lengths (L~FL~), round weights (RW), upper jaw lengths (L~UJ~),  eye diameters (L~ED~), interorbital distances (L~ID~), snout lengths (L~SL~), post orbital to preoperculum distances (L~PP~), post orbital head lengths (L~PO~), females (F), males (M), sagittal otoliths and operculum clips (DNA) listed by survey.
\ \
\ \

```{r table3, results="asis",echo=FALSE, warning=FALSE, message=FALSE}

    sample <- paste("select  CASE WHEN TRIP_ID = 0 THEN 'Salmon' WHEN trip_id = 80378 THEN '2016 WCHG'  ",
                    " ELSE '2016 WCVI ' END AS Survey,  ",
                    " SUM(FL) AS FL, SUM(WR) AS WR, SUM(UJ) AS UJ, SUM(ED) AS ED, ",
                    " SUM(ID) AS ID, SUM(SL) AS SL, SUM(PP) AS PP, SUM(PH) AS PO, ",
                    " SUM(F) AS F,   SUM(M) AS M,   SUM(O)  AS Otoliths,  ",
                    " SUM(D) AS DNA, SUM(FL) AS Total  from    ",       
                    " (SELECT   TRIP_ID, CASE WHEN Fork_Length > 0 THEN 1 ELSE 0 END AS FL, ",
                    "  CASE WHEN Whole_Round_Weight > 0 THEN 1 ELSE 0 END AS WR, ",
                    "  CASE WHEN Upper_jaw_length > 0 THEN 1 ELSE 0 END AS UJ,   ",
                    "  CASE WHEN Eye_Diameter > 0 THEN 1 ELSE 0 END AS ED, ",
                    "  CASE WHEN InterOrbital_distance > 0 THEN 1 ELSE 0 END AS ID, ",
                    "  CASE WHEN Snout_length > 0 THEN 1 ELSE 0 END AS SL, ",
                    "  CASE WHEN Postorbital_Preoperculum > 0 THEN 1 ELSE 0 END AS PP, ",
                    "  CASE WHEN Post_orbital_Head_length > 0 THEN 1 ELSE 0 END AS PH, ",
                    "  CASE WHEN SPECIMEN_SEX_DESC = 'FEMALE' THEN 1 ELSE 0 END AS F, ",
                    "  CASE WHEN SPECIMEN_SEX_DESC = 'MALE' THEN 1 ELSE 0 END AS M, ",
                    "  CASE WHEN Otoliths_Collected = 'Y' THEN 1 ELSE 0 END AS O,  ",
                    "  CASE WHEN DNA_Collected = 'Y' THEN 1 ELSE 0 END AS D  ",
                    "  from dbo.Head_Measurements_Report) AS Samples ",
                    "  group by CASE WHEN TRIP_ID = 0 THEN 'Salmon' WHEN trip_id = 80378  ",
                    "  THEN '2016 WCHG' ELSE '2016 WCVI ' END", sep="")
   # samplecnt <-    GetSQLData(sample,"Sablefish")  # -- counts of biological samples
   # write.table(samplecnt , file = paste(path,"Table3.csv", sep=''), row.names=FALSE, na="", col.names=TRUE, sep=",")
   samplecnt <- read.csv(paste(path,'Table3.csv',sep=''),header=T)  # read from csv
   
   last.line  <-   c('Total', sum(samplecnt$FL), sum(samplecnt$RW),
                         sum(samplecnt$UJ), sum(samplecnt$ED),
                         sum(samplecnt$ID), sum(samplecnt$SL),
                         sum(samplecnt$PP), sum(samplecnt$PO),
                         sum(samplecnt$F),  sum(samplecnt$M),
                         sum(samplecnt$Otoliths), sum(samplecnt$DNA),sum(samplecnt$Total))
   samplecnt$Survey <- as.character(samplecnt$Survey)
   samplecnt        <- rbind(samplecnt, last.line)
   
   kableExtra::kable(samplecnt, booktabs = TRUE, 
                     col.names = c("Survey", "L\\textsubscript{FL}", "RW", 
                                   "L\\textsubscript{UJ}", "L\\textsubscript{ED}", 
                                   "L\\textsubscript{ID}", "L\\textsubscript{SL}", 
                                   "L\\textsubscript{PP}", "L\\textsubscript{PO}", 
                                   "F", "M", "Otoliths", "DNA", "Total"),
                     format = "latex", 
                     linesep = "",
                     row.names=FALSE,
                     escape = F, # allows textsuperscript latex
                     caption = "(ref:Table3Caption)") %>%
   
   kableExtra::kable_styling(font_size = 10, position = "left",latex_options = "hold_position") %>%
                     row_spec(0, bold="true")  %>%
                     row_spec(4, bold="true") %>%
                     row_spec(3, hline_after = T)
   
```
\ \
\ \
\ \
(ref:Table4Caption) Statistics associated with simple linear regressions using measurements (mm) of cranial lengths: upper jaw length (L~UJ~), eye diameter (L~ED~), interorbital distance (L~ID~), snout length (L~SL~), post orbital to preoperculum length (L~PP~) and post orbital head length (L~PO~) as predictors of the fork length (L~FL~) of 438 sablefish collected from research surveys in 2016.  All models were significant at P <0.001. 
\ \
\ \

```{r table4, echo=FALSE}

     head.stats$symbol  <-  c(paste("L", "\\textsubscript{UJ}", sep=''), paste("L", "\\textsubscript{UJ}", sep=''),
                              paste("L", "\\textsubscript{ED}", sep=''), paste("L", "\\textsubscript{ED}", sep=''),
                              paste("L", "\\textsubscript{ID}", sep=''), paste("L", "\\textsubscript{ID}", sep=''),
                              paste("L", "\\textsubscript{SL}", sep=''), paste("L", "\\textsubscript{SL}", sep=''),
                              paste("L", "\\textsubscript{PP}", sep=''), paste("L", "\\textsubscript{PP}", sep=''),
                              paste("L", "\\textsubscript{PO}", sep=''), paste("L", "\\textsubscript{PO}", sep=''))
     head.stats$name  <- NULL
     head.stats$measurement <- NULL
     head.stats  <- head.stats[,c(11,1,2,3,4,5,6,7,8,9,10)]
     head.stats$symbol <- cleanf(head.stats$symbol)  # remove duplicate names

     kableExtra::kable(head.stats, col.names = c("Cranial Measurement","Sex","N","Slope","SE","R\\textsuperscript{2}","r","Mean","SD","Mean","SD"),
                      booktabs = TRUE, 
                      linesep = "", row.names=FALSE, escape = F, # need escape to show superscript
                      align = c("l","l","c","c","c","c","c","c","c","c"),
                      format = "latex",  caption = "(ref:Table4Caption)") %>%

     add_header_above(c(" "=7, "Predictor"= 2, "Response L$_{FL}$" = 2), bold=T, escape = F) %>% 
     kableExtra::kable_styling(font_size = 10, position = "left",latex_options = "hold_position") %>%
                      row_spec(0, bold = "true") %>%
                      row_spec(c(2,4,6,8,10), hline_after = T) %>%
                      column_spec(1, width  = "2.2cm") %>%
                      column_spec(2, width  = "1.2cm") %>%
                      column_spec(3, width  = "0.7cm") %>%
                      column_spec(4, width  = "0.7cm") %>%
                      column_spec(5, width  = "0.7cm") %>%
                      column_spec(6, width  = "0.7cm") %>%
                      column_spec(7, width  = "0.8cm") %>%
                      column_spec(8, width  = "0.8cm") %>%
                      column_spec(9, width  = "0.8cm") %>%
                      column_spec(10, width = "0.8cm") %>%
                      column_spec(11, width = "0.8cm")
    
```
(ref:Table5Caption) Ease of use and repeatable five point ranking scale recorded by experienced samplers for each cranial measurement for the 2016 experimental study, where 5 = Great; 4 = Good; 3 = Moderate; 2 = Questionable; 1 = Poor. 

```{r table5, echo=FALSE}

#  Notes:  on each head dimension manual calipers for >15cm distances other metrics indicate if calipers were limited after >15 cm,  bilateral 
#   measurements were possible and if the measurement involved bone.

 options(knitr.kable.NA = '')

     repeatable   <-  read.csv(paste(path,"Table5.csv", sep=""), header=T)
     #table4[1,3] <-  lmR(lm(Fork_Length ~ Upper_jaw_length, data=hdUj))   # r value if needed 
     #table4[2,3] <-  lmR(lm(Fork_Length ~ Eye_Diameter, data=hdEd))
     #table4[3,3] <-  lmR(lm(Fork_Length ~ InterOrbital_Distance, data=hdId))
     #table4[4,3] <-  lmR(lm(Fork_Length ~ Snout_length, data=hdSl))
     #table4[5,3] <-  lmR(lm(Fork_Length ~ Postorbital_Preoperculum, data=hdPop))
     #table4[6,3] <-  lmR(lm(Fork_Length ~ Post_orbital_Head_length, data=hdPo))
     
     repeatable  <-  repeatable[,c(-2)] 
     repeatable$symbol  <-  c(paste("L", "\\textsubscript{UJ}", sep=''),
                              paste("L", "\\textsubscript{ED}", sep=''),
                              paste("L", "\\textsubscript{ID}", sep=''),
                              paste("L", "\\textsubscript{SL}", sep=''),
                              paste("L", "\\textsubscript{PP}", sep=''),
                              paste("L", "\\textsubscript{PO}", sep=''))
     repeatable$Measurement  <- NULL
     repeatable  <- repeatable[,c(7,1,2,3,4,5,6)]
     
     
     names(repeatable)  <- c("Head Dimension",    
                             "Ease of use", "Repeatable", 
                             "Caliper limitation", "Bilateral", 
                             "Bone",   "Considerations")
     
     kableExtra::kable(repeatable,
                     booktabs = TRUE,
                     linesep = "",
                     escape = F, # need escape to show superscript
                     align = c("c","c","c","c","c","c","l"),
                     format = "latex",  caption = "(ref:Table5Caption)") %>%
                     row_spec(1,  hline_after = T) %>%
                     row_spec(2,  hline_after = T) %>%
                     row_spec(3,  hline_after = T) %>%
                     row_spec(4,  hline_after = T) %>%
                     row_spec(5,  hline_after = T) %>%

     add_header_above(c(" "= 1, "5 Point Rank" = 2, "Measurement" = 3, " " = 1), bold=T) %>%   
             
     kableExtra::kable_styling(font_size = 10, position = "left") %>%
                      row_spec(0, bold="true") %>%
                      column_spec(1, width  = "1.4cm") %>%
                      column_spec(2, width  = "0.9cm") %>%
                      column_spec(3, width  = "1.7cm") %>%
                      column_spec(4, width  = "1.2cm") %>%
                      column_spec(5, width  = "1.7cm") %>%
                      column_spec(6, width  = "1.7cm") %>%
                      column_spec(7, width  = "4.6cm")        

```

```{r table6words, echo=FALSE}

sample99cnt <- read.csv(paste(path,'head_measurements_Seamount_Pilot.csv',sep=''),header=T)  # read from csv

cobb.count  <- nrow(sample99cnt[sample99cnt$White.bag.label=="COBB",])
eick.count  <- nrow(sample99cnt[sample99cnt$White.bag.label=="EICKELBERG",])

``` 

\ \
(ref:Table6Caption) Summary of sablefish biological data collected from the 2017 pilot study to Cobb (n=`r cobb.count`) and Eickelberg (n=`r eick.count`) seamounts, measured by three expert technicians using a standardized protocol for the 2017 pilot study.  Index of Average Error (IAE) % values are reported for each of the cranial lengths.
\ \

```{r table6, echo=FALSE}


   samples.data <- read.csv(paste(path,'export.samples.csv',sep=''),header=T)  # read from csv created in the index.rmd
   IAE.value        <- c(IAE.UJ,IAE.ID,IAE.SL,IAE.PP)
   
#  separate out by sampler

   pilot.table <- as.data.frame(cbind(meas.name=c(     paste("L", "\\textsubscript{UJ}", sep=''),paste("L", "\\textsubscript{ID}", sep=''),
                                                       paste("L", "\\textsubscript{SL}", sep=''),paste("L", "\\textsubscript{PP}", sep='')) ,                          
                                   samplerA = c(       paste(min(sample99cnt$Upper.jaw.lengthA)," - ", max(sample99cnt$Upper.jaw.lengthA), sep=''),  
                                                       paste(min(sample99cnt$InterOrbital.DistanceA)," - ", max(sample99cnt$InterOrbital.DistanceA), sep=''),                                                       
                                                       paste(min(sample99cnt$Snout.lengthA)," - ", max(sample99cnt$Snout.lengthA), sep=''),
                                                       paste(min(sample99cnt$Post.orbital.to.PreoperculumA)," - ", max(sample99cnt$Post.orbital.to.PreoperculumA), sep='')) ,
                                   samplerB = c(       paste(min(sample99cnt$Upper.jaw.lengthB)," - ", max(sample99cnt$Upper.jaw.lengthB), sep=''),
                                                       paste(min(sample99cnt$InterOrbital.DistanceB)," - ", max(sample99cnt$InterOrbital.DistanceB), sep=''),                                                       
                                                       paste(min(sample99cnt$Snout.lengthB)," - ", max(sample99cnt$Snout.lengthB), sep=''),
                                                       paste(min(sample99cnt$Post.orbital.to.PreoperculumB)," - ", max(sample99cnt$Post.orbital.to.PreoperculumB), sep='')) ,
                                   samplerC = c(       paste(min(sample99cnt$Upper.jaw.lengthC)," - ", max(sample99cnt$Upper.jaw.lengthC), sep=''),
                                                       paste(min(sample99cnt$InterOrbital.DistanceC)," - ", max(sample99cnt$InterOrbital.DistanceC), sep=''),
                                                       paste(min(sample99cnt$Snout.lengthC)," - ", max(sample99cnt$Snout.lengthC), sep=''),
                                                       paste(min(sample99cnt$Post.orbital.to.PreoperculumC)," - ", max(sample99cnt$Post.orbital.to.PreoperculumC), sep='')) ,
                                   males   =  c(       nrow(sample99cnt[sample99cnt$Sex=="M",]), nrow(sample99cnt[sample99cnt$Sex=="M",]), 
                                                       nrow(sample99cnt[sample99cnt$Sex=="M",]), nrow(sample99cnt[sample99cnt$Sex=="M",])) ,
                                   females =  c(       nrow(sample99cnt[sample99cnt$Sex=="F",]), nrow(sample99cnt[sample99cnt$Sex=="F",]), 
                                                       nrow(sample99cnt[sample99cnt$Sex=="F",]), nrow(sample99cnt[sample99cnt$Sex=="F",])),
                                   IAE.value        <- c(IAE.UJ,IAE.ID,IAE.SL,IAE.PP)
                                   ))

   kableExtra::kable(pilot.table, 
                     booktabs = TRUE, col.names = c("Head Dimension", "Min - Max (mm)", "Min - Max (mm)","Min - Max (mm)", "Males", "Females", "IAE"), 
                     linesep = "",
                     escape = F, 
                     align = c("l","c","c","c","c","c","l"),
                     format = "latex",  caption = "(ref:Table6Caption)") %>%
     
    add_header_above(c(" "= 1, "Sampler A" = 1, "Sampler B" = 1, "Sampler C" = 1, "Sex"=2, " " = 1 ), bold = T) %>% 
   
    kableExtra::kable_styling(font_size = 10, position = "left") %>%
                      row_spec(0, bold="true") %>%
                      column_spec(1, width  = "1.7cm") %>%
                      column_spec(2, width  = "2.2cm") %>%
                      column_spec(3, width  = "2.2cm") %>%
                      column_spec(4, width  = "2.2cm") %>%
                      column_spec(5, width  = "1.3cm") %>%
                      column_spec(6, width  = "1.3cm") %>% 
                      column_spec(7, width  = "1.3cm") 


```
\clearpage


<!--chapter:end:04_tables.Rmd-->

# Figures

(ref:figure1) Sample locations from the 2016 WCVI, WCHG and salmon research surveys and 2017 pilot study.

```{r figure1, fig.cap='(ref:figure1)',warning=FALSE, echo=FALSE, message=FALSE, error= FALSE, width=5.9, height=8.5, fig.align='center'}

    library(here)
    library(rgdal)
    library(ggfortify)

    png("C:/github/sablehead/figures/Figure1.png", units="px", width=1600, height=1800, res=150) # write png to file
    sql          <-   "select * from Head_Measurements_Report where SLAT > 0"  # head measurement data
    #pointdata    <-   GetSQLData(sql,"Sablefish")   # retrieve from seamount database
    #write.table(pointdata, file = paste(path,"figure1.csv",sep=''),row.names=FALSE, na="",col.names=TRUE,  sep=",") 
    #pointdata    <-  read.csv(paste(path,'figure1.csv',sep=''),header=T)  # read from csv
    
    #K.Holt: changed pointdata to use here function when reading
    pointdata    <-read.csv(here("standalone", "figure1.csv"))
    
    lon          <-   data.frame(pointdata$SLAT)
    lat          <-   data.frame(pointdata$SLON)
    spid         <-   data.frame(pointdata$SPECIMEN_ID)
    trip         <-   data.frame(pointdata$TRIP_ID)
    df           <-   as.data.frame(cbind(lon,lat,spid,trip))   # add year, lat, long, specimen_id to dataframe

    # add pilot survey coordinates for general fishing area
    a <- c(46.7093,-130.82812, 1, 338773 ) #  cobb
    b <- c(48.2828,-133.204, 2, 338773 )    #   eickelburg
    
    df           <-  rbind(df,a)
    df           <-  rbind(df,b)
   
    canada       <-   readOGR(dsn = "C:/github/sablehead/storage",layer ="awscntry_geo", verbose = FALSE)  # open shapefile   
    shapef_can   <-   fortify(canada)    # fortify for ggplot require.
    points_df    <-   fortify(df)
    
    seamounts    <-   readOGR(dsn = "C:/github/sablehead/storage",layer ="twoSeamounts_geo", verbose = FALSE)  # open shapefile
    seam_can     <-   fortify(seamounts)    # fortify for ggplot require.
    
    map          <-  ggplot() +
                     geom_polygon(data = shapef_can,  
                                  aes(x = long, y = lat, group = group), 
                                      fill="gray40",  
                                      size = .2) +
                     geom_polygon(data = seam_can, aes(x = long, y =  lat, group = group), color = "lightgray", alpha = 0, linetype = 1)  +
                     geom_point(data =   points_df,   aes(pointdata.SLON, pointdata.SLAT,  
                                                          fill=factor(pointdata.TRIP_ID),  size=0.7) , 
                                                          colour="lightgray", shape=21, size=5) + 
                     geom_text(aes(x =  -130.000, y = 46.7093, label = "Cobb"),
                                    alpha = 1,
                                    color = "grey40")  +
                     geom_text(aes(x =  -131.6040, y = 48.2828, label = "Eickelberg"),
                                    alpha = 1,
                                    color = "grey40")  +
                     theme_minimal()    +
                     guides(fill="none") + 
                     guides(size="none") + 
                     guides(fill=guide_legend(title="Trip")) +
                     xlab("Longitude") + ylab("Latitude") + 
                     theme(  text = element_text(size=20),
                             plot.title      = element_blank(),
                             legend.position = c(.29, 0.45),
                             legend.justification = c("right", "top"),
                             legend.box.just = "right",
                             legend.margin = margin(6, 6, 6, 6)
                          )   
   
    map_projected  <- map +   # reproject to make it look better
    coord_map()  +
    annotation_north_arrow(location = "bl", which_north = "true",  # north arrow
                           pad_x  = unit(1.0, "cm"),  
                           pad_y  = unit(2.5,  "cm"),
                           height = unit(2.5,  "cm"),
                           width  = unit(2.5,  "cm"),
                           style  = north_arrow_fancy_orienteering)
    
    map_projected        +
    annotation_scale(location = "bl",
                     pad_x = unit(0.5, "in"),  
                     pad_y = unit(0.3, "in"),
                     height = unit(0.5, "cm"),
                     width  = unit(5.95,"cm"),
                     text_cex = 1.0)   +
                     coord_sf(crs = 4326)  +
                     scale_fill_discrete(name = "Research Trip", labels = c("Salmon", "WCVI", "WCHG","Seamount Pilot"))

    while (!is.null(dev.list()))  dev.off()
    img <-   paste('C:/github/sablehead/figures/Figure1.png',sep="")   # -- retrieve png 
            knitr::include_graphics(img)
   
 
```
```{r figure_data_fit_regression_male_female}
  
  #  fit the regression lines and get the prediction results separately for male, female and head measurements
  #  before putting in ggplot - very necessary 
     
     cranial.f                     <-  hdUj[hdUj$SPECIMEN_SEX_DESC=="FEMALE",]  # Upper jaw  length data
     cranial.f$n                   <-  length(cranial.f$HeadBarcode)                   # number of specimens 
     cranial.fit.outliers.f        <-  lm(Fork_Length ~ Upper_jaw_length, data=cranial.f)  # linear regression model #plot(hd.fit.outliers, which = 1, pch=21) 
     cranial.fit.outliersummary.f  <-  summary(cranial.fit.outliers.f)                 # summary

     cranial.f$predicted           <-  predict(cranial.fit.outliers.f)   # save the predicted values
     cranial.f$residuals           <-  residuals(cranial.fit.outliers.f) # save the residual values

     cranial.m                     <-  hdUj[hdUj$SPECIMEN_SEX_DESC=="MALE",]  # snout length data
     cranial.m$n                   <-  length(cranial.m$HeadBarcode)                   # number of specimens 
     cranial.fit.outliers.m        <-  lm(Fork_Length ~ Upper_jaw_length, data=cranial.m)  # linear regression model #plot(hd.fit.outliers, which = 1, pch=21) 
     cranial.fit.outliersummary.m  <-  summary(cranial.fit.outliers.m)                 # summary

     cranial.m$predicted           <-  predict(cranial.fit.outliers.m)   # save the predicted values
     cranial.m$residuals           <-  residuals(cranial.fit.outliers.m) # save the residual values

     cranial.uj  <-  rbind( cranial.f, cranial.m )
     names(cranial.uj)[6] <- "hlength" 

     cranial.f                     <-  hdEd[hdEd$SPECIMEN_SEX_DESC=="FEMALE",]  # Eye Diameter length data
     cranial.f$n                   <-  length(cranial.f$HeadBarcode)                   # number of specimens 
     cranial.fit.outliers.f        <-  lm(Fork_Length ~ Eye_Diameter, data=cranial.f)  # linear regression model #plot(hd.fit.outliers, which = 1, pch=21) 
     cranial.fit.outliersummary.f  <-  summary(cranial.fit.outliers.f)                 # summary

     cranial.f$predicted           <-  predict(cranial.fit.outliers.f)   # save the predicted values
     cranial.f$residuals           <-  residuals(cranial.fit.outliers.f) # save the residual values

     cranial.m                     <-  hdEd[hdEd$SPECIMEN_SEX_DESC=="MALE",]  # snout length data
     cranial.m$n                   <-  length(cranial.m$HeadBarcode)                   # number of specimens 
     cranial.fit.outliers.m        <-  lm(Fork_Length ~ Eye_Diameter, data=cranial.m)  # linear regression model #plot(hd.fit.outliers, which = 1, pch=21) 
     cranial.fit.outliersummary.m  <-  summary(cranial.fit.outliers.m)                 # summary

     cranial.m$predicted           <-  predict(cranial.fit.outliers.m)   # save the predicted values
     cranial.m$residuals           <-  residuals(cranial.fit.outliers.m) # save the residual values

     cranial.ed  <-  rbind( cranial.f, cranial.m )
     names(cranial.ed)[6] <- "hlength"

     cranial.f                     <-  hdId[hdId$SPECIMEN_SEX_DESC=="FEMALE",]  # InterOrbital distance data
     cranial.f$n                   <-  length(cranial.f$HeadBarcode)                   # number of specimens 
     cranial.fit.outliers.f        <-  lm(Fork_Length ~ InterOrbital_Distance, data=cranial.f)  # linear regression model #plot(hd.fit.outliers, which = 1, pch=21) 
     cranial.fit.outliersummary.f  <-  summary(cranial.fit.outliers.f)                 # summary

     cranial.f$predicted           <-  predict(cranial.fit.outliers.f)   # save the predicted values
     cranial.f$residuals           <-  residuals(cranial.fit.outliers.f) # save the residual values

     cranial.m                     <-  hdId[hdId$SPECIMEN_SEX_DESC=="MALE",]  # snout length data
     cranial.m$n                   <-  length(cranial.m$HeadBarcode)                   # number of specimens 
     cranial.fit.outliers.m        <-  lm(Fork_Length ~ InterOrbital_Distance, data=cranial.m)  # linear regression model #plot(hd.fit.outliers, which = 1, pch=21) 
     cranial.fit.outliersummary.m  <-  summary(cranial.fit.outliers.m)                 # summary

     cranial.m$predicted           <-  predict(cranial.fit.outliers.m)   # save the predicted values
     cranial.m$residuals           <-  residuals(cranial.fit.outliers.m) # save the residual values

     cranial.id  <-  rbind( cranial.f, cranial.m )
     names(cranial.id)[6] <- "hlength"

     cranial.f                     <-  hdSl[hdSl$SPECIMEN_SEX_DESC=="FEMALE",]         # Snout length data
     cranial.f$n                   <-  length(cranial.f$HeadBarcode)                   # number of specimens 
     cranial.fit.outliers.f        <-  lm(Fork_Length ~ Snout_length, data=cranial.f)  # linear regression model #plot(hd.fit.outliers, which = 1, pch=21) 
     cranial.fit.outliersummary.f  <-  summary(cranial.fit.outliers.f)                 # summary

     cranial.f$predicted           <-  predict(cranial.fit.outliers.f)   # save the predicted values
     cranial.f$residuals           <-  residuals(cranial.fit.outliers.f) # save the residual values

     cranial.m                     <-  hdSl[hdSl$SPECIMEN_SEX_DESC=="MALE",]  # snout length data
     cranial.m$n                   <-  length(cranial.m$HeadBarcode)                   # number of specimens 
     cranial.fit.outliers.m        <-  lm(Fork_Length ~ Snout_length, data=cranial.m)  # linear regression model #plot(hd.fit.outliers, which = 1, pch=21) 
     cranial.fit.outliersummary.m  <-  summary(cranial.fit.outliers.m)                 # summary

     cranial.m$predicted           <-  predict(cranial.fit.outliers.m)   # save the predicted values
     cranial.m$residuals           <-  residuals(cranial.fit.outliers.m) # save the residual values

     cranial.sl <-  rbind( cranial.f, cranial.m )
     names(cranial.sl)[6] <- "hlength"
     
     cranial.f                     <-  hdPop[hdPop$SPECIMEN_SEX_DESC=="FEMALE",]  # Postorbital_Preoperculum length data
     cranial.f$n                   <-  length(cranial.f$HeadBarcode)              # number of specimens 
     cranial.fit.outliers.f        <-  lm(Fork_Length ~ Postorbital_Preoperculum, data=cranial.f)  # linear regression model #plot(hd.fit.outliers, which = 1, pch=21) 
     cranial.fit.outliersummary.f  <-  summary(cranial.fit.outliers.f)         # summary

     cranial.f$predicted           <-  predict(cranial.fit.outliers.f)   # save the predicted values
     cranial.f$residuals           <-  residuals(cranial.fit.outliers.f) # save the residual values

     cranial.m                     <-  hdPop[hdPop$SPECIMEN_SEX_DESC=="MALE",]  # snout length data
     cranial.m$n                   <-  length(cranial.m$HeadBarcode)                   # number of specimens 
     cranial.fit.outliers.m        <-  lm(Fork_Length ~ Postorbital_Preoperculum, data=cranial.m)  # linear regression model #plot(hd.fit.outliers, which = 1, pch=21) 
     cranial.fit.outliersummary.m  <-  summary(cranial.fit.outliers.m)         # summary

     cranial.m$predicted           <-  predict(cranial.fit.outliers.m)   # save the predicted values
     cranial.m$residuals           <-  residuals(cranial.fit.outliers.m) # save the residual values

     cranial.pp <-  rbind( cranial.f, cranial.m )
     names(cranial.pp)[6] <- "hlength"

     cranial.f                     <-  hdPo[hdPo$SPECIMEN_SEX_DESC=="FEMALE",]  # Post orbital Head length data
     cranial.f$n                   <-  length(cranial.f$HeadBarcode)              # number of specimens 
     cranial.fit.outliers.f        <-  lm(Fork_Length ~ Post_orbital_Head_length, data=cranial.f)  # linear regression model #plot(hd.fit.outliers, which = 1, pch=21) 
     cranial.fit.outliersummary.f  <-  summary(cranial.fit.outliers.f)         # summary

     cranial.f$predicted           <-  predict(cranial.fit.outliers.f)   # save the predicted values
     cranial.f$residuals           <-  residuals(cranial.fit.outliers.f) # save the residual values

     cranial.m                     <-  hdPo[hdPo$SPECIMEN_SEX_DESC=="MALE",]  # snout length data
     cranial.m$n                   <-  length(cranial.m$HeadBarcode)                   # number of specimens 
     cranial.fit.outliers.m        <-  lm(Fork_Length ~ Post_orbital_Head_length, data=cranial.m)  # linear regression model #plot(hd.fit.outliers, which = 1, pch=21) 
     cranial.fit.outliersummary.m  <-  summary(cranial.fit.outliers.m)         # summary

     cranial.m$predicted           <-  predict(cranial.fit.outliers.m)   # save the predicted values
     cranial.m$residuals           <-  residuals(cranial.fit.outliers.m) # save the residual values

     cranial.po <-  rbind( cranial.f, cranial.m )
     names(cranial.po)[6] <- "hlength"

   
```
(ref:figure2) Relationship between cranial lengths (UJ, ED, ID) vs fork length in millimeters.  Predicted points represented by black circles, measured values colored by residual scale.

```{r figure2, fig.cap='(ref:figure2)', results='asis', out.width = "470px", fig.align='left'}
   
     png("C:/github/sablehead/figures/Figure2.png", units="px", width=2300, height=2700, res=500) # write png to file

     library(viridis)
     
     cranial <- rbind(cranial.uj,cranial.ed, cranial.id)  # facet wrap all 5 cranial measurements
     cranial$facet = factor(cranial$measure, levels = c("UJ", "ED", "ID"))

     ggplot(cranial, aes(x = hlength, y = Fork_Length)) +
            scale_y_continuous(limits = c(200, 1200)) +
            ylab('Fork length (mm)') +
            xlab("Cranial dimension (mm)") + 
            geom_smooth(method = "lm",se = FALSE,color = "grey") +                          # plot regression slope
            geom_segment(aes(xend = hlength, yend = predicted), color= "black", size=0.15, alpha = .35) +  # lines
                              # color residuals https://drsimonj.svbtle.com/visualising-residuals
            geom_point(aes(color = abs(residuals), size = abs(residuals))) +                # residuals
            scale_size(range=c(0.1,0.9)) + 
            scale_color_gradient2(low = "grey", mid = "#1ebecd", high = "orange")  +   
            guides( size = FALSE) +
       
            geom_point(aes(y = predicted), shape = 20, size=0.25)     +    # plot predicted circles
       
                stat_regline_equation(label.x=85, label.y=450, aes(label = ..eq.label..), size=2.1, 
                                      label.x.npc = "right",
                                      label.y.npc = "bottom") +   # y = mx+b and r2 values added to plot
       
                stat_regline_equation(label.x=85, label.y = 350,  aes(label = ..rr.label..), size=2.1,
                                      label.x.npc = "right",
                                      label.y.npc = "bottom") +  # r square value
       
                stat_cor( aes(label = paste(
                      if_else(readr::parse_number(..p.label..) < 0.001,    # p value
                              "p<0.001", ..p.label..), sep = "~`,   `~")),
                               label.x=85,
                               label.y = 250, size=2.1,
                               label.x.npc = "right",
                               label.y.npc = "bottom")  +
                geom_text(size=2.0, aes(x=20,y=1140,label= paste0("n=",n)))  +
                
                facet_grid( facet ~ SPECIMEN_SEX_DESC) +   # facet wrap
       
                theme(legend.position=c(0.87,0.56),legend.key.size = unit(1.4, 'mm'),    # legend position
                      legend.text=element_text(size=6), legend.title = element_text(size=6)) +
                theme(legend.box = 'horizontal')  + 
                labs(color="residuals") + 
                      theme(strip.text.x = element_text(size=7),
                      strip.text.y = element_text(size=7),
                      strip.background = element_rect(size=0.25,colour="black", fill="lightgray")) +
                      theme(panel.border = element_rect(color = "black",
                                    fill = NA,
                                    size = 0.25)) +
                      theme(axis.title.y = element_text(size = 7), axis.title.x = element_text(size = 7) ) +
                      theme(axis.text = element_text(size = 6)) +
                      theme(panel.background = element_rect(fill = "white",
                                colour = "white",
                                size = 0.35, linetype = "solid"),  # control the grey lines
                                panel.grid.major = element_line(size = 0.125, linetype = 'solid',
                                colour = "grey"), 
                                panel.grid.minor = element_line(size = 0.125, linetype = 'solid',
                                colour = "grey"))

     while (!is.null(dev.list()))  dev.off()
     img <-   paste('C:/github/sablehead/figures/figure2.png',sep="")   # -- retrieve png 
              knitr::include_graphics(img)
     
```
(ref:figure3) Relationship between cranial lengths (SL, PP, PO) vs fork length in millimeters.    Predicted points represented by black circles, measured values colored by residual scale.

```{r figure3, fig.cap='(ref:figure3)', results='asis',  out.width = "470px", fig.align='left'}
   
     png("C:/github/sablehead/figures/Figure3.png", units="px", width=2300, height=2700, res=500) # write png to file
      
     cranial <- rbind(cranial.sl, cranial.pp, cranial.po)  # facet wrap all 3 cranial measurements
     cranial$facet = factor(cranial$measure, levels = c("SL","PP","PO"))
 
     ggplot(cranial, aes(x = hlength, y = Fork_Length)) +
            scale_y_continuous(limits = c(200, 1200)) +
            ylab('Fork length (mm)') +
            xlab("Cranial dimension (mm)") + 
            geom_smooth(method = "lm",se = FALSE,color = "grey") +                          # plot regression slope
            geom_segment(aes(xend = hlength, yend = predicted), color= "black", size=0.15, alpha = .35) +  # lines
                              # color residuals https://drsimonj.svbtle.com/visualising-residuals
            geom_point(aes(color = abs(residuals), size = abs(residuals))) +                # residuals
            scale_size(range=c(0.1,0.9)) + 
            scale_color_gradient2(low = "grey", mid = "#1ebecd", high = "orange")  +   
            guides( size = FALSE) +
       
            geom_point(aes(y = predicted), shape = 20, size=0.25)     +    # plot predicted circles
       
                stat_regline_equation(label.x=100, label.y=450, aes(label = ..eq.label..), size=2.1, 
                                      label.x.npc = "right",
                                      label.y.npc = "bottom") +   # y = mx+b and r2 values added to plot
       
                stat_regline_equation(label.x=100, label.y = 350,  aes(label = ..rr.label..), size=2.1,
                                      label.x.npc = "right",
                                      label.y.npc = "bottom") +  # r square value
       
                stat_cor( aes(label = paste(
                      if_else(readr::parse_number(..p.label..) < 0.001,    # p value
                              "p<0.001", ..p.label..), sep = "~`,   `~")),
                               label.x=100,
                               label.y = 250, size=2.1,
                               label.x.npc = "right",
                               label.y.npc = "bottom")  +
                geom_text(size=2.0, aes(x=20,y=1140,label= paste0("n=",n)))  +
                
                facet_grid( facet ~ SPECIMEN_SEX_DESC) +   # facet wrap
       
                theme(legend.position=c(0.87,0.56),legend.key.size = unit(1.4, 'mm'),    # legend position
                      legend.text=element_text(size=6), legend.title = element_text(size=6)) +
                theme(legend.box = 'horizontal')  + 
                labs(color="residuals") + 
                      theme(strip.text.x = element_text(size=7),
                      strip.text.y = element_text(size=7),
                      strip.background = element_rect(size=0.25,colour="black", fill="lightgray")) +
                      theme(panel.border = element_rect(color = "black",
                                    fill = NA,
                                    size = 0.25)) +
                      theme(axis.title.y = element_text(size = 7), axis.title.x = element_text(size = 7) ) +
                      theme(axis.text = element_text(size = 6)) +
                      theme(panel.background = element_rect(fill = "white",
                                colour = "white",
                                size = 0.35, linetype = "solid"),  # control the grey lines
                                panel.grid.major = element_line(size = 0.125, linetype = 'solid',
                                colour = "grey"), 
                                panel.grid.minor = element_line(size = 0.125, linetype = 'solid',
                                colour = "grey"))

     while (!is.null(dev.list()))  dev.off()
     img <-   paste('C:/github/sablehead/figures/figure3.png',sep="")   # -- retrieve png 
              knitr::include_graphics(img)
     
```



\clearpage

<!--chapter:end:04_figures.Rmd-->

<!-- The following code should appear at the beginning of the first appendix.
(if you have one)
After that, all subsequent sections will be turned into appendices. -->

`r if(knitr:::is_latex_output()) '% begin csasdown appendix'`

`r if(!knitr:::is_latex_output()) '# (APPENDIX) Appendix {-}'`

\clearpage

# IMAGES OF THE SIX CRANIAL DIMENSION MEASUREMENTS.{#app:first-appendix}

A. Upper jaw measurement (UJ);  B. Eye diameter measurement (ED);  C. Interorbital distance (ID);  D. Snout length (SL);  E. Post orbital to preoperculum length measurement (PP); F. Post orbital head length (PO).


```{r appendixA}
 png(paste(graph_directory,"AppendixA.png", sep=""), units="px", width=1600, height=1800, res=150)# write png to file
    
   img         <- readPNG(paste(graph_directory,"AppendixAa.png", sep=""))
   g           <- rasterGrob(img, interpolate=TRUE)   # get image A. Upper jaw measurement
   img2        <- readPNG(paste(graph_directory,"AppendixAb.png", sep=""))
   g2          <- rasterGrob(img2, interpolate=TRUE)  # get image B. Eye diameter measurement
   img3        <- readPNG(paste(graph_directory,"AppendixAc.png", sep=""))
   g3          <- rasterGrob(img3, interpolate=TRUE)  # get image C. Interorbital measurement
   img4        <- readPNG(paste(graph_directory,"AppendixAd.png", sep=""))
   g4          <- rasterGrob(img4, interpolate=TRUE)  # get image D. Snout length 
   img5        <- readPNG(paste(graph_directory,"AppendixAe.png", sep=""))
   g5          <- rasterGrob(img5, interpolate=TRUE)  # get image E. Post orbital to preoperculum length measurement
   img6        <- readPNG(paste(graph_directory,"AppendixAf.png", sep=""))
   g6          <- rasterGrob(img6, interpolate=TRUE)  # get image F. Post orbital head length.   
 
   ggplot(data.frame(x = 1:3, y = 1:3), aes(x, y)) +
          geom_point(size = 0.00001, color="white") +

          annotation_custom(g,   xmin = 0.7,    xmax = 2.1,   ymin = 2.45,  ymax = 3.2)   +   
          #geom_text(x=0.99,  y=2.7, label="A.", size=0.6, color="white") + 
          annotation_custom(g2,  xmin = 1.87,   xmax = 3.2,   ymin = 2.45,  ymax = 3.2)   +   
          #geom_text(x=2.1,   y=2.7, label="B.", size=0.6, color="white") +  
          annotation_custom(g3,  xmin = 0.7,    xmax = 2.1,   ymin = 1.65,  ymax = 2.4)   +    
          #geom_text(x=0.99,  y=2.0, label="C.", size=0.6, color="white") + 
          annotation_custom(g4,  xmin = 1.87,   xmax = 3.2,   ymin = 1.65,  ymax = 2.4)   +   
          #geom_text(x=2.1,   y=2.0, label="D.", size=0.6, color="white") +  
          annotation_custom(g5,  xmin = 0.7,    xmax = 2.1,   ymin = 0.85,  ymax = 1.6)   +   
          #geom_text(x=0.99,  y=1.22,label="E.", size=0.6, color="white") +  
          annotation_custom(g6,  xmin = 1.87,   xmax = 3.35,  ymin = 0.85,  ymax = 1.6)   +   
          #geom_text(x=2.1,   y=1.22,label="F.", size=0.6, color="white") +
          theme(axis.title.x = element_text(colour = "white"),
          axis.title.y = element_text(colour = "white"),
          text=element_text(color="white"),
          axis.text=element_text(color="white"),
          panel.background = element_rect(fill = 'white', color = 'white'),
          axis.ticks.y = element_blank(),
          axis.ticks.x = element_blank()) 
         
   
     while (!is.null(dev.list()))  dev.off()
     img <-   paste(paste(graph_directory,"AppendixA.png", sep=""))   # -- retrieve png 
              knitr::include_graphics(img)
```

\clearpage

# SEX DETERMINATION BY OPERCULUM MARKING {#app:second-appendix}

Instructions for sex determinations and operculum knife cuts for sablefish males and females.

```{r AppendixB, results='asis'}
img <- paste(graph_directory,'AppendixB.png',sep='') 
      knitr::include_graphics(img)
```
\clearpage

<!-- At the end of your appendices add: -->
`r if(knitr:::is_latex_output()) '% end csasdown appendix'`

<!--chapter:end:05_appendix.Rmd-->

<!-- If you want to references to appear somewhere before the end, add: -->
<!-- <div id="refs"></div> -->
<!-- where you want it to appear -->

<!-- In general, you shouldn't need to edit this file with the exception of
the following French/English translation. For a French document, set the following header to: # RÃ©fÃ©rences CitÃ©es  {-} -->

\clearpage

# References

<!-- The following sets the appropriate indentation for the references -->
\noindent
\vspace{-2em}
\setlength{\parindent}{-0.2in}
\setlength{\leftskip}{0.2in}
\setlength{\parskip}{8pt}

<!--chapter:end:06_bibliography.Rmd-->

